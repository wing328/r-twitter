#' Twitter API v2
#'
#' Twitter API v2 available endpoints
#'
#' The version of the OpenAPI document: 2.49
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Users operations
#' @description UsersApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ find_my_user } \emph{ User lookup me }
#' This endpoint returns information about the requesting User.
#'
#' \itemize{
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2UsersMeResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersMeResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ find_user_by_id } \emph{ User lookup by ID }
#' This endpoint returns information about a User. Specify User by ID.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2UsersIdResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersIdResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ find_user_by_username } \emph{ User lookup by username }
#' This endpoint returns information about a User. Specify User by username.
#'
#' \itemize{
#' \item \emph{ @param } username character
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2UsersByUsernameUsernameResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersByUsernameUsernameResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ find_users_by_id } \emph{ User lookup by IDs }
#' This endpoint returns information about Users. Specify Users by their ID.
#'
#' \itemize{
#' \item \emph{ @param } ids list( character )
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2UsersResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ find_users_by_username } \emph{ User lookup by usernames }
#' This endpoint returns information about Users. Specify Users by their username.
#'
#' \itemize{
#' \item \emph{ @param } usernames list( character )
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2UsersByResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersByResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ list_get_followers } \emph{ Returns User objects that follow a List by the provided List ID }
#' Returns a list of Users that follow a List by the provided List ID
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2ListsIdFollowersResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2ListsIdFollowersResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ list_get_members } \emph{ Returns User objects that are members of a List by the provided List ID. }
#' Returns a list of Users that are members of a List by the provided List ID.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2ListsIdMembersResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2ListsIdMembersResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ tweets_id_liking_users } \emph{ Returns User objects that have liked the provided Tweet ID }
#' Returns a list of Users that have liked the provided Tweet ID
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2TweetsIdLikingUsersResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2TweetsIdLikingUsersResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ tweets_id_retweeting_users } \emph{ Returns User objects that have retweeted the provided Tweet ID }
#' Returns a list of Users that have retweeted the provided Tweet ID
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2TweetsIdRetweetedByResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2TweetsIdRetweetedByResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_block } \emph{ Block User by User ID }
#' Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } block_user_request \link{BlockUserRequest}
#' \item \emph{ @returnType } \link{BlockUserMutationResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : BlockUserMutationResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_blocking } \emph{ Returns User objects that are blocked by provided User ID }
#' Returns a list of Users that are blocked by the provided User ID
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2UsersIdBlockingResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersIdBlockingResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_follow } \emph{ Follow User }
#' Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } users_following_create_request \link{UsersFollowingCreateRequest}
#' \item \emph{ @returnType } \link{UsersFollowingCreateResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : UsersFollowingCreateResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_followers } \emph{ Returns User objects that follow a List by the provided User ID }
#' Returns a list of Users that follow the provided User ID
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2UsersIdFollowersResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersIdFollowersResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_following } \emph{ Following by User ID }
#' Returns a list of Users that are being followed by the provided User ID
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2UsersIdFollowingResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersIdFollowingResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_mute } \emph{ Mute User by User ID. }
#' Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } mute_user_request \link{MuteUserRequest}
#' \item \emph{ @returnType } \link{MuteUserMutationResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : MuteUserMutationResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_muting } \emph{ Returns User objects that are muted by the provided User ID }
#' Returns a list of Users that are muted by the provided User ID
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2UsersIdMutingResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersIdMutingResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_unblock } \emph{ Unblock User by User ID }
#' Causes the source User to unblock the target User. The source User must match the User context authorizing the request
#'
#' \itemize{
#' \item \emph{ @param } source_user_id character
#' \item \emph{ @param } target_user_id character
#' \item \emph{ @returnType } \link{BlockUserMutationResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : BlockUserMutationResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_unfollow } \emph{ Unfollow User }
#' Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
#'
#' \itemize{
#' \item \emph{ @param } source_user_id character
#' \item \emph{ @param } target_user_id character
#' \item \emph{ @returnType } \link{UsersFollowingDeleteResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : UsersFollowingDeleteResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_unmute } \emph{ Unmute User by User ID }
#' Causes the source User to unmute the target User. The source User must match the User context authorizing the request
#'
#' \itemize{
#' \item \emph{ @param } source_user_id character
#' \item \emph{ @param } target_user_id character
#' \item \emph{ @returnType } \link{MuteUserMutationResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : MuteUserMutationResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  find_my_user  ####################
#'
#' library(twitter)
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #User lookup me
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$find_my_user(user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$find_my_user(user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `find_my_user`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  find_user_by_id  ####################
#'
#' library(twitter)
#' var_id <- "2244994945" # character | The ID of the User to lookup.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #User lookup by ID
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$find_user_by_id(var_id, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$find_user_by_id(var_id, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `find_user_by_id`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  find_user_by_username  ####################
#'
#' library(twitter)
#' var_username <- "TwitterDev" # character | A username.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #User lookup by username
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$find_user_by_username(var_username, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$find_user_by_username(var_username, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `find_user_by_username`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  find_users_by_id  ####################
#'
#' library(twitter)
#' var_ids <- ["2244994945,6253282,12"] # array[character] | A list of User IDs, comma-separated. You can specify up to 100 IDs.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #User lookup by IDs
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$find_users_by_id(var_ids, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$find_users_by_id(var_ids, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `find_users_by_id`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  find_users_by_username  ####################
#'
#' library(twitter)
#' var_usernames <- ["TwitterDev,TwitterAPI"] # array[character] | A list of usernames, comma-separated.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #User lookup by usernames
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$find_users_by_username(var_usernames, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$find_users_by_username(var_usernames, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `find_users_by_username`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  list_get_followers  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the List.
#' var_max_results <- 100 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get a specified 'page' of results.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #Returns User objects that follow a List by the provided List ID
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$list_get_followers(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$list_get_followers(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `list_get_followers`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  list_get_members  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the List.
#' var_max_results <- 100 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get a specified 'page' of results.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #Returns User objects that are members of a List by the provided List ID.
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$list_get_members(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$list_get_members(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `list_get_members`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  tweets_id_liking_users  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | A single Tweet ID.
#' var_max_results <- 100 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #Returns User objects that have liked the provided Tweet ID
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$tweets_id_liking_users(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$tweets_id_liking_users(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `tweets_id_liking_users`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  tweets_id_retweeting_users  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | A single Tweet ID.
#' var_max_results <- 100 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #Returns User objects that have retweeted the provided Tweet ID
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$tweets_id_retweeting_users(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$tweets_id_retweeting_users(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `tweets_id_retweeting_users`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_block  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the authenticated source User that is requesting to block the target User.
#' var_block_user_request <- BlockUserRequest$new() # BlockUserRequest | 
#'
#' #Block User by User ID
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$users_id_block(var_id, var_block_user_request, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$users_id_block(var_id, var_block_user_request),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_block`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_blocking  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the authenticated source User for whom to return results.
#' var_max_results <- 56 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get a specified 'page' of results.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #Returns User objects that are blocked by provided User ID
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$users_id_blocking(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$users_id_blocking(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_blocking`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_follow  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the authenticated source User that is requesting to follow the target User.
#' var_users_following_create_request <- UsersFollowingCreateRequest$new() # UsersFollowingCreateRequest | 
#'
#' #Follow User
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$users_id_follow(var_id, users_following_create_request = var_users_following_create_request, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$users_id_follow(var_id, users_following_create_request = var_users_following_create_request),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_follow`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_followers  ####################
#'
#' library(twitter)
#' var_id <- "2244994945" # character | The ID of the User to lookup.
#' var_max_results <- 56 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get a specified 'page' of results.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #Returns User objects that follow a List by the provided User ID
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$users_id_followers(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$users_id_followers(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_followers`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_following  ####################
#'
#' library(twitter)
#' var_id <- "2244994945" # character | The ID of the User to lookup.
#' var_max_results <- 56 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get a specified 'page' of results.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #Following by User ID
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$users_id_following(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$users_id_following(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_following`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_mute  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the authenticated source User that is requesting to mute the target User.
#' var_mute_user_request <- MuteUserRequest$new() # MuteUserRequest | 
#'
#' #Mute User by User ID.
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$users_id_mute(var_id, mute_user_request = var_mute_user_request, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$users_id_mute(var_id, mute_user_request = var_mute_user_request),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_mute`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_muting  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the authenticated source User for whom to return results.
#' var_max_results <- 100 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #Returns User objects that are muted by the provided User ID
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$users_id_muting(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$users_id_muting(var_id, max_results = var_max_results, pagination_token = var_pagination_token, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_muting`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_unblock  ####################
#'
#' library(twitter)
#' var_source_user_id <- "source_user_id_example" # character | The ID of the authenticated source User that is requesting to unblock the target User.
#' var_target_user_id <- "target_user_id_example" # character | The ID of the User that the source User is requesting to unblock.
#'
#' #Unblock User by User ID
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$users_id_unblock(var_source_user_id, var_target_user_id, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$users_id_unblock(var_source_user_id, var_target_user_id),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_unblock`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_unfollow  ####################
#'
#' library(twitter)
#' var_source_user_id <- "source_user_id_example" # character | The ID of the authenticated source User that is requesting to unfollow the target User.
#' var_target_user_id <- "target_user_id_example" # character | The ID of the User that the source User is requesting to unfollow.
#'
#' #Unfollow User
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$users_id_unfollow(var_source_user_id, var_target_user_id, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$users_id_unfollow(var_source_user_id, var_target_user_id),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_unfollow`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_unmute  ####################
#'
#' library(twitter)
#' var_source_user_id <- "source_user_id_example" # character | The ID of the authenticated source User that is requesting to unmute the target User.
#' var_target_user_id <- "target_user_id_example" # character | The ID of the User that the source User is requesting to unmute.
#'
#' #Unmute User by User ID
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$users_api$users_id_unmute(var_source_user_id, var_target_user_id, data_file = "result.txt"),
#'              
#'              
#'              api_instance$users_api$users_id_unmute(var_source_user_id, var_target_user_id),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_unmute`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @importFrom rlang abort
#' @export
UsersApi <- R6::R6Class(
  "UsersApi",
  public = list(
    api_client = NULL,
    #' Initialize a new UsersApi.
    #'
    #' @description
    #' Initialize a new UsersApi.
    #'
    #' @param api_client An instance of API client.
    #' @export
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },
    #' User lookup me
    #'
    #' @description
    #' User lookup me
    #'
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersMeResponse
    #' @export
    find_my_user = function(user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$find_my_user_with_http_info(user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' User lookup me
    #'
    #' @description
    #' User lookup me
    #'
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersMeResponse) with additional information such as HTTP status code, headers
    #' @export
    find_my_user_with_http_info = function(user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$find_my_user, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$find_my_user, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$find_my_user, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$find_my_user, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$find_my_user, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$find_my_user, number of items must be greater than or equal to 1."))
      }

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$find_my_user. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$find_my_user. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$find_my_user. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$find_my_user. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$find_my_user. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$find_my_user. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$find_my_user. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$find_my_user. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$find_my_user. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$find_my_user. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$find_my_user. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$find_my_user. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/me"
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersMeResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' User lookup by ID
    #'
    #' @description
    #' User lookup by ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersIdResponse
    #' @export
    find_user_by_id = function(id, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$find_user_by_id_with_http_info(id, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' User lookup by ID
    #'
    #' @description
    #' User lookup by ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersIdResponse) with additional information such as HTTP status code, headers
    #' @export
    find_user_by_id_with_http_info = function(id, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling UsersApi$find_user_by_id, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling UsersApi$find_user_by_id, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$find_user_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$find_user_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$find_user_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$find_user_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$find_user_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$find_user_by_id, number of items must be greater than or equal to 1."))
      }

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$find_user_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$find_user_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$find_user_by_id. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$find_user_by_id. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$find_user_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$find_user_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$find_user_by_id. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$find_user_by_id. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$find_user_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$find_user_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$find_user_by_id. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$find_user_by_id. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/{id}"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersIdResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' User lookup by username
    #'
    #' @description
    #' User lookup by username
    #'
    #' @param username A username.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersByUsernameUsernameResponse
    #' @export
    find_user_by_username = function(username, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$find_user_by_username_with_http_info(username, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' User lookup by username
    #'
    #' @description
    #' User lookup by username
    #'
    #' @param username A username.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersByUsernameUsernameResponse) with additional information such as HTTP status code, headers
    #' @export
    find_user_by_username_with_http_info = function(username, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`username`)) {
        rlang::abort(message = "Missing required parameter `username`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `username`."))
      }

      if (!str_detect(`username`, "^[A-Za-z0-9_]{1,15}$")) {
        rlang::abort(message = "Invalid value for `username` when calling UsersApi$find_user_by_username, must conform to the pattern ^[A-Za-z0-9_]{1,15}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `username` when calling UsersApi$find_user_by_username, must conform to the pattern ^[A-Za-z0-9_]{1,15}$."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$find_user_by_username, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$find_user_by_username, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$find_user_by_username, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$find_user_by_username, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$find_user_by_username, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$find_user_by_username, number of items must be greater than or equal to 1."))
      }

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$find_user_by_username. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$find_user_by_username. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$find_user_by_username. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$find_user_by_username. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$find_user_by_username. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$find_user_by_username. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$find_user_by_username. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$find_user_by_username. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$find_user_by_username. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$find_user_by_username. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$find_user_by_username. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$find_user_by_username. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/by/username/{username}"
      if (!missing(`username`)) {
        local_var_url_path <- gsub(paste0("\\{", "username", "\\}"), URLencode(as.character(`username`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersByUsernameUsernameResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' User lookup by IDs
    #'
    #' @description
    #' User lookup by IDs
    #'
    #' @param ids A list of User IDs, comma-separated. You can specify up to 100 IDs.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersResponse
    #' @export
    find_users_by_id = function(ids, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$find_users_by_id_with_http_info(ids, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' User lookup by IDs
    #'
    #' @description
    #' User lookup by IDs
    #'
    #' @param ids A list of User IDs, comma-separated. You can specify up to 100 IDs.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersResponse) with additional information such as HTTP status code, headers
    #' @export
    find_users_by_id_with_http_info = function(ids, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`ids`)) {
        rlang::abort(message = "Missing required parameter `ids`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `ids`."))
      }

      if (length(`ids`) > 100) {
        rlang::abort(message = "Invalid length for `ids` when calling UsersApi$find_users_by_id, number of items must be less than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `ids` when calling UsersApi$find_users_by_id, number of items must be less than or equal to 100."))
      }
      if (length(`ids`) < 1) {
        rlang::abort(message = "Invalid length for `ids` when calling UsersApi$find_users_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `ids` when calling UsersApi$find_users_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$find_users_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$find_users_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$find_users_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$find_users_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$find_users_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$find_users_by_id, number of items must be greater than or equal to 1."))
      }

      # no explore
      query_params[["ids"]] <- I(paste(lapply(`ids`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$find_users_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$find_users_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$find_users_by_id. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$find_users_by_id. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$find_users_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$find_users_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$find_users_by_id. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$find_users_by_id. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$find_users_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$find_users_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$find_users_by_id. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$find_users_by_id. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' User lookup by usernames
    #'
    #' @description
    #' User lookup by usernames
    #'
    #' @param usernames A list of usernames, comma-separated.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersByResponse
    #' @export
    find_users_by_username = function(usernames, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$find_users_by_username_with_http_info(usernames, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' User lookup by usernames
    #'
    #' @description
    #' User lookup by usernames
    #'
    #' @param usernames A list of usernames, comma-separated.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersByResponse) with additional information such as HTTP status code, headers
    #' @export
    find_users_by_username_with_http_info = function(usernames, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`usernames`)) {
        rlang::abort(message = "Missing required parameter `usernames`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `usernames`."))
      }

      if (length(`usernames`) > 100) {
        rlang::abort(message = "Invalid length for `usernames` when calling UsersApi$find_users_by_username, number of items must be less than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `usernames` when calling UsersApi$find_users_by_username, number of items must be less than or equal to 100."))
      }
      if (length(`usernames`) < 1) {
        rlang::abort(message = "Invalid length for `usernames` when calling UsersApi$find_users_by_username, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `usernames` when calling UsersApi$find_users_by_username, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$find_users_by_username, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$find_users_by_username, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$find_users_by_username, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$find_users_by_username, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$find_users_by_username, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$find_users_by_username, number of items must be greater than or equal to 1."))
      }

      # no explore
      query_params[["usernames"]] <- I(paste(lapply(`usernames`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$find_users_by_username. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$find_users_by_username. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$find_users_by_username. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$find_users_by_username. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$find_users_by_username. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$find_users_by_username. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$find_users_by_username. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$find_users_by_username. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$find_users_by_username. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$find_users_by_username. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$find_users_by_username. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$find_users_by_username. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/by"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersByResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Returns User objects that follow a List by the provided List ID
    #'
    #' @description
    #' Returns User objects that follow a List by the provided List ID
    #'
    #' @param id The ID of the List.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2ListsIdFollowersResponse
    #' @export
    list_get_followers = function(id, max_results = 100, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$list_get_followers_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Returns User objects that follow a List by the provided List ID
    #'
    #' @description
    #' Returns User objects that follow a List by the provided List ID
    #'
    #' @param id The ID of the List.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2ListsIdFollowersResponse) with additional information such as HTTP status code, headers
    #' @export
    list_get_followers_with_http_info = function(id, max_results = 100, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling UsersApi$list_get_followers, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling UsersApi$list_get_followers, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$list_get_followers, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$list_get_followers, must be smaller than or equal to 100."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$list_get_followers, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$list_get_followers, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) > 19) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling UsersApi$list_get_followers, must be smaller than or equal to 19.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for $pagination_token when calling UsersApi.list_get_followers, must be smaller than or equal to 19."))
      }
      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling UsersApi$list_get_followers, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling UsersApi$list_get_followers, must be bigger than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$list_get_followers, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$list_get_followers, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$list_get_followers, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$list_get_followers, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$list_get_followers, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$list_get_followers, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$list_get_followers. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$list_get_followers. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$list_get_followers. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$list_get_followers. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$list_get_followers. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$list_get_followers. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$list_get_followers. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$list_get_followers. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$list_get_followers. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$list_get_followers. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$list_get_followers. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$list_get_followers. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/lists/{id}/followers"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read list.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2ListsIdFollowersResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Returns User objects that are members of a List by the provided List ID.
    #'
    #' @description
    #' Returns User objects that are members of a List by the provided List ID.
    #'
    #' @param id The ID of the List.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2ListsIdMembersResponse
    #' @export
    list_get_members = function(id, max_results = 100, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$list_get_members_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Returns User objects that are members of a List by the provided List ID.
    #'
    #' @description
    #' Returns User objects that are members of a List by the provided List ID.
    #'
    #' @param id The ID of the List.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2ListsIdMembersResponse) with additional information such as HTTP status code, headers
    #' @export
    list_get_members_with_http_info = function(id, max_results = 100, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling UsersApi$list_get_members, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling UsersApi$list_get_members, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$list_get_members, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$list_get_members, must be smaller than or equal to 100."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$list_get_members, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$list_get_members, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) > 19) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling UsersApi$list_get_members, must be smaller than or equal to 19.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for $pagination_token when calling UsersApi.list_get_members, must be smaller than or equal to 19."))
      }
      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling UsersApi$list_get_members, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling UsersApi$list_get_members, must be bigger than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$list_get_members, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$list_get_members, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$list_get_members, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$list_get_members, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$list_get_members, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$list_get_members, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$list_get_members. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$list_get_members. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$list_get_members. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$list_get_members. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$list_get_members. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$list_get_members. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$list_get_members. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$list_get_members. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$list_get_members. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$list_get_members. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$list_get_members. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$list_get_members. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/lists/{id}/members"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read list.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2ListsIdMembersResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Returns User objects that have liked the provided Tweet ID
    #'
    #' @description
    #' Returns User objects that have liked the provided Tweet ID
    #'
    #' @param id A single Tweet ID.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2TweetsIdLikingUsersResponse
    #' @export
    tweets_id_liking_users = function(id, max_results = 100, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$tweets_id_liking_users_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Returns User objects that have liked the provided Tweet ID
    #'
    #' @description
    #' Returns User objects that have liked the provided Tweet ID
    #'
    #' @param id A single Tweet ID.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2TweetsIdLikingUsersResponse) with additional information such as HTTP status code, headers
    #' @export
    tweets_id_liking_users_with_http_info = function(id, max_results = 100, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling UsersApi$tweets_id_liking_users, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling UsersApi$tweets_id_liking_users, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$tweets_id_liking_users, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$tweets_id_liking_users, must be smaller than or equal to 100."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$tweets_id_liking_users, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$tweets_id_liking_users, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling UsersApi$tweets_id_liking_users, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling UsersApi$tweets_id_liking_users, must be bigger than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$tweets_id_liking_users, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$tweets_id_liking_users, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$tweets_id_liking_users, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$tweets_id_liking_users, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$tweets_id_liking_users, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$tweets_id_liking_users, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$tweets_id_liking_users. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$tweets_id_liking_users. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$tweets_id_liking_users. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$tweets_id_liking_users. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$tweets_id_liking_users. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$tweets_id_liking_users. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$tweets_id_liking_users. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$tweets_id_liking_users. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$tweets_id_liking_users. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$tweets_id_liking_users. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$tweets_id_liking_users. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$tweets_id_liking_users. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/{id}/liking_users"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read like.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2TweetsIdLikingUsersResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Returns User objects that have retweeted the provided Tweet ID
    #'
    #' @description
    #' Returns User objects that have retweeted the provided Tweet ID
    #'
    #' @param id A single Tweet ID.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2TweetsIdRetweetedByResponse
    #' @export
    tweets_id_retweeting_users = function(id, max_results = 100, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$tweets_id_retweeting_users_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Returns User objects that have retweeted the provided Tweet ID
    #'
    #' @description
    #' Returns User objects that have retweeted the provided Tweet ID
    #'
    #' @param id A single Tweet ID.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2TweetsIdRetweetedByResponse) with additional information such as HTTP status code, headers
    #' @export
    tweets_id_retweeting_users_with_http_info = function(id, max_results = 100, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling UsersApi$tweets_id_retweeting_users, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling UsersApi$tweets_id_retweeting_users, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$tweets_id_retweeting_users, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$tweets_id_retweeting_users, must be smaller than or equal to 100."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$tweets_id_retweeting_users, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$tweets_id_retweeting_users, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling UsersApi$tweets_id_retweeting_users, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling UsersApi$tweets_id_retweeting_users, must be bigger than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$tweets_id_retweeting_users, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$tweets_id_retweeting_users, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$tweets_id_retweeting_users, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$tweets_id_retweeting_users, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$tweets_id_retweeting_users, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$tweets_id_retweeting_users, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$tweets_id_retweeting_users. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$tweets_id_retweeting_users. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$tweets_id_retweeting_users. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$tweets_id_retweeting_users. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$tweets_id_retweeting_users. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$tweets_id_retweeting_users. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$tweets_id_retweeting_users. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$tweets_id_retweeting_users. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$tweets_id_retweeting_users. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$tweets_id_retweeting_users. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$tweets_id_retweeting_users. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$tweets_id_retweeting_users. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/{id}/retweeted_by"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2TweetsIdRetweetedByResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Block User by User ID
    #'
    #' @description
    #' Block User by User ID
    #'
    #' @param id The ID of the authenticated source User that is requesting to block the target User.
    #' @param block_user_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return BlockUserMutationResponse
    #' @export
    users_id_block = function(id, block_user_request, data_file = NULL, ...) {
      local_var_response <- self$users_id_block_with_http_info(id, block_user_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Block User by User ID
    #'
    #' @description
    #' Block User by User ID
    #'
    #' @param id The ID of the authenticated source User that is requesting to block the target User.
    #' @param block_user_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (BlockUserMutationResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_block_with_http_info = function(id, block_user_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (missing(`block_user_request`)) {
        rlang::abort(message = "Missing required parameter `block_user_request`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `block_user_request`."))
      }



      if (!missing(`block_user_request`)) {
        local_var_body <- `block_user_request`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/2/users/{id}/blocking"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read block.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "BlockUserMutationResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Returns User objects that are blocked by provided User ID
    #'
    #' @description
    #' Returns User objects that are blocked by provided User ID
    #'
    #' @param id The ID of the authenticated source User for whom to return results.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersIdBlockingResponse
    #' @export
    users_id_blocking = function(id, max_results = NULL, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_blocking_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Returns User objects that are blocked by provided User ID
    #'
    #' @description
    #' Returns User objects that are blocked by provided User ID
    #'
    #' @param id The ID of the authenticated source User for whom to return results.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersIdBlockingResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_blocking_with_http_info = function(id, max_results = NULL, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }


      if (`max_results` > 1000) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$users_id_blocking, must be smaller than or equal to 1000.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$users_id_blocking, must be smaller than or equal to 1000."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$users_id_blocking, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$users_id_blocking, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) < 16) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling UsersApi$users_id_blocking, must be bigger than or equal to 16.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling UsersApi$users_id_blocking, must be bigger than or equal to 16."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$users_id_blocking, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$users_id_blocking, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$users_id_blocking, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$users_id_blocking, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$users_id_blocking, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$users_id_blocking, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$users_id_blocking. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$users_id_blocking. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$users_id_blocking. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$users_id_blocking. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$users_id_blocking. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$users_id_blocking. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$users_id_blocking. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$users_id_blocking. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$users_id_blocking. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$users_id_blocking. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$users_id_blocking. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$users_id_blocking. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/{id}/blocking"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read block.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersIdBlockingResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Follow User
    #'
    #' @description
    #' Follow User
    #'
    #' @param id The ID of the authenticated source User that is requesting to follow the target User.
    #' @param users_following_create_request (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return UsersFollowingCreateResponse
    #' @export
    users_id_follow = function(id, users_following_create_request = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_follow_with_http_info(id, users_following_create_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Follow User
    #'
    #' @description
    #' Follow User
    #'
    #' @param id The ID of the authenticated source User that is requesting to follow the target User.
    #' @param users_following_create_request (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (UsersFollowingCreateResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_follow_with_http_info = function(id, users_following_create_request = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }



      if (!missing(`users_following_create_request`)) {
        local_var_body <- `users_following_create_request`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/2/users/{id}/following"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read follows.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "UsersFollowingCreateResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Returns User objects that follow a List by the provided User ID
    #'
    #' @description
    #' Returns User objects that follow a List by the provided User ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersIdFollowersResponse
    #' @export
    users_id_followers = function(id, max_results = NULL, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_followers_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Returns User objects that follow a List by the provided User ID
    #'
    #' @description
    #' Returns User objects that follow a List by the provided User ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersIdFollowersResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_followers_with_http_info = function(id, max_results = NULL, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling UsersApi$users_id_followers, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling UsersApi$users_id_followers, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 1000) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$users_id_followers, must be smaller than or equal to 1000.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$users_id_followers, must be smaller than or equal to 1000."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$users_id_followers, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$users_id_followers, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) < 16) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling UsersApi$users_id_followers, must be bigger than or equal to 16.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling UsersApi$users_id_followers, must be bigger than or equal to 16."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$users_id_followers, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$users_id_followers, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$users_id_followers, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$users_id_followers, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$users_id_followers, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$users_id_followers, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$users_id_followers. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$users_id_followers. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$users_id_followers. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$users_id_followers. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$users_id_followers. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$users_id_followers. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$users_id_followers. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$users_id_followers. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$users_id_followers. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$users_id_followers. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$users_id_followers. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$users_id_followers. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/{id}/followers"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read follows.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersIdFollowersResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Following by User ID
    #'
    #' @description
    #' Following by User ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersIdFollowingResponse
    #' @export
    users_id_following = function(id, max_results = NULL, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_following_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Following by User ID
    #'
    #' @description
    #' Following by User ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersIdFollowingResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_following_with_http_info = function(id, max_results = NULL, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling UsersApi$users_id_following, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling UsersApi$users_id_following, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 1000) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$users_id_following, must be smaller than or equal to 1000.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$users_id_following, must be smaller than or equal to 1000."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$users_id_following, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$users_id_following, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) < 16) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling UsersApi$users_id_following, must be bigger than or equal to 16.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling UsersApi$users_id_following, must be bigger than or equal to 16."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$users_id_following, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$users_id_following, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$users_id_following, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$users_id_following, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$users_id_following, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$users_id_following, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$users_id_following. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$users_id_following. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$users_id_following. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$users_id_following. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$users_id_following. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$users_id_following. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$users_id_following. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$users_id_following. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$users_id_following. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$users_id_following. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$users_id_following. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$users_id_following. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/{id}/following"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read follows.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersIdFollowingResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Mute User by User ID.
    #'
    #' @description
    #' Mute User by User ID.
    #'
    #' @param id The ID of the authenticated source User that is requesting to mute the target User.
    #' @param mute_user_request (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return MuteUserMutationResponse
    #' @export
    users_id_mute = function(id, mute_user_request = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_mute_with_http_info(id, mute_user_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Mute User by User ID.
    #'
    #' @description
    #' Mute User by User ID.
    #'
    #' @param id The ID of the authenticated source User that is requesting to mute the target User.
    #' @param mute_user_request (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (MuteUserMutationResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_mute_with_http_info = function(id, mute_user_request = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }



      if (!missing(`mute_user_request`)) {
        local_var_body <- `mute_user_request`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/2/users/{id}/muting"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read mute.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "MuteUserMutationResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Returns User objects that are muted by the provided User ID
    #'
    #' @description
    #' Returns User objects that are muted by the provided User ID
    #'
    #' @param id The ID of the authenticated source User for whom to return results.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersIdMutingResponse
    #' @export
    users_id_muting = function(id, max_results = 100, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_muting_with_http_info(id, max_results, pagination_token, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Returns User objects that are muted by the provided User ID
    #'
    #' @description
    #' Returns User objects that are muted by the provided User ID
    #'
    #' @param id The ID of the authenticated source User for whom to return results.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersIdMutingResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_muting_with_http_info = function(id, max_results = 100, pagination_token = NULL, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }


      if (`max_results` > 1000) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$users_id_muting, must be smaller than or equal to 1000.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$users_id_muting, must be smaller than or equal to 1000."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling UsersApi$users_id_muting, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling UsersApi$users_id_muting, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) > 19) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling UsersApi$users_id_muting, must be smaller than or equal to 19.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for $pagination_token when calling UsersApi.users_id_muting, must be smaller than or equal to 19."))
      }
      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling UsersApi$users_id_muting, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling UsersApi$users_id_muting, must be bigger than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling UsersApi$users_id_muting, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling UsersApi$users_id_muting, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling UsersApi$users_id_muting, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling UsersApi$users_id_muting, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling UsersApi$users_id_muting, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling UsersApi$users_id_muting, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$users_id_muting. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling UsersApi$users_id_muting. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling UsersApi$users_id_muting. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling UsersApi$users_id_muting. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$users_id_muting. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling UsersApi$users_id_muting. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling UsersApi$users_id_muting. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling UsersApi$users_id_muting. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$users_id_muting. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling UsersApi$users_id_muting. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling UsersApi$users_id_muting. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling UsersApi$users_id_muting. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/{id}/muting"
      if (!missing(`id`)) {
        local_var_url_path <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read mute.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersIdMutingResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Unblock User by User ID
    #'
    #' @description
    #' Unblock User by User ID
    #'
    #' @param source_user_id The ID of the authenticated source User that is requesting to unblock the target User.
    #' @param target_user_id The ID of the User that the source User is requesting to unblock.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return BlockUserMutationResponse
    #' @export
    users_id_unblock = function(source_user_id, target_user_id, data_file = NULL, ...) {
      local_var_response <- self$users_id_unblock_with_http_info(source_user_id, target_user_id, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Unblock User by User ID
    #'
    #' @description
    #' Unblock User by User ID
    #'
    #' @param source_user_id The ID of the authenticated source User that is requesting to unblock the target User.
    #' @param target_user_id The ID of the User that the source User is requesting to unblock.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (BlockUserMutationResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_unblock_with_http_info = function(source_user_id, target_user_id, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`source_user_id`)) {
        rlang::abort(message = "Missing required parameter `source_user_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `source_user_id`."))
      }

      if (missing(`target_user_id`)) {
        rlang::abort(message = "Missing required parameter `target_user_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `target_user_id`."))
      }


      if (!str_detect(`target_user_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `target_user_id` when calling UsersApi$users_id_unblock, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `target_user_id` when calling UsersApi$users_id_unblock, must conform to the pattern ^[0-9]{1,19}$."))
      }

      local_var_url_path <- "/2/users/{source_user_id}/blocking/{target_user_id}"
      if (!missing(`source_user_id`)) {
        local_var_url_path <- gsub(paste0("\\{", "source_user_id", "\\}"), URLencode(as.character(`source_user_id`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`target_user_id`)) {
        local_var_url_path <- gsub(paste0("\\{", "target_user_id", "\\}"), URLencode(as.character(`target_user_id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read block.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "DELETE",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "BlockUserMutationResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Unfollow User
    #'
    #' @description
    #' Unfollow User
    #'
    #' @param source_user_id The ID of the authenticated source User that is requesting to unfollow the target User.
    #' @param target_user_id The ID of the User that the source User is requesting to unfollow.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return UsersFollowingDeleteResponse
    #' @export
    users_id_unfollow = function(source_user_id, target_user_id, data_file = NULL, ...) {
      local_var_response <- self$users_id_unfollow_with_http_info(source_user_id, target_user_id, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Unfollow User
    #'
    #' @description
    #' Unfollow User
    #'
    #' @param source_user_id The ID of the authenticated source User that is requesting to unfollow the target User.
    #' @param target_user_id The ID of the User that the source User is requesting to unfollow.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (UsersFollowingDeleteResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_unfollow_with_http_info = function(source_user_id, target_user_id, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`source_user_id`)) {
        rlang::abort(message = "Missing required parameter `source_user_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `source_user_id`."))
      }

      if (missing(`target_user_id`)) {
        rlang::abort(message = "Missing required parameter `target_user_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `target_user_id`."))
      }


      if (!str_detect(`target_user_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `target_user_id` when calling UsersApi$users_id_unfollow, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `target_user_id` when calling UsersApi$users_id_unfollow, must conform to the pattern ^[0-9]{1,19}$."))
      }

      local_var_url_path <- "/2/users/{source_user_id}/following/{target_user_id}"
      if (!missing(`source_user_id`)) {
        local_var_url_path <- gsub(paste0("\\{", "source_user_id", "\\}"), URLencode(as.character(`source_user_id`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`target_user_id`)) {
        local_var_url_path <- gsub(paste0("\\{", "target_user_id", "\\}"), URLencode(as.character(`target_user_id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read follows.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "DELETE",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "UsersFollowingDeleteResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Unmute User by User ID
    #'
    #' @description
    #' Unmute User by User ID
    #'
    #' @param source_user_id The ID of the authenticated source User that is requesting to unmute the target User.
    #' @param target_user_id The ID of the User that the source User is requesting to unmute.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return MuteUserMutationResponse
    #' @export
    users_id_unmute = function(source_user_id, target_user_id, data_file = NULL, ...) {
      local_var_response <- self$users_id_unmute_with_http_info(source_user_id, target_user_id, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Unmute User by User ID
    #'
    #' @description
    #' Unmute User by User ID
    #'
    #' @param source_user_id The ID of the authenticated source User that is requesting to unmute the target User.
    #' @param target_user_id The ID of the User that the source User is requesting to unmute.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (MuteUserMutationResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_unmute_with_http_info = function(source_user_id, target_user_id, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`source_user_id`)) {
        rlang::abort(message = "Missing required parameter `source_user_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `source_user_id`."))
      }

      if (missing(`target_user_id`)) {
        rlang::abort(message = "Missing required parameter `target_user_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `target_user_id`."))
      }


      if (!str_detect(`target_user_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `target_user_id` when calling UsersApi$users_id_unmute, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `target_user_id` when calling UsersApi$users_id_unmute, must conform to the pattern ^[0-9]{1,19}$."))
      }

      local_var_url_path <- "/2/users/{source_user_id}/muting/{target_user_id}"
      if (!missing(`source_user_id`)) {
        local_var_url_path <- gsub(paste0("\\{", "source_user_id", "\\}"), URLencode(as.character(`source_user_id`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`target_user_id`)) {
        local_var_url_path <- gsub(paste0("\\{", "target_user_id", "\\}"), URLencode(as.character(`target_user_id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read mute.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "DELETE",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "MuteUserMutationResponse", loadNamespace("twitter")),
          error = function(e) {
             rlang::abort(message = "Failed to deserialize response",
                          .subclass = "ApiException",
                          ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    }
  )
)
