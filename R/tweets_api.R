#' Twitter API v2
#'
#' Twitter API v2 available endpoints
#'
#' The version of the OpenAPI document: 2.49
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Tweets operations
#' @description TweetsApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ add_or_delete_rules } \emph{ Add/Delete rules }
#' Add or delete rules from a User's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
#'
#' \itemize{
#' \item \emph{ @param } add_or_delete_rules_request \link{AddOrDeleteRulesRequest}
#' \item \emph{ @param } dry_run character
#' \item \emph{ @returnType } \link{AddOrDeleteRulesResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : AddOrDeleteRulesResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ create_tweet } \emph{ Creation of a Tweet }
#' Causes the User to create a Tweet under the authorized account.
#'
#' \itemize{
#' \item \emph{ @param } tweet_create_request \link{TweetCreateRequest}
#' \item \emph{ @returnType } \link{TweetCreateResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 201 | The request has succeeded.
#'
#' \item return type : TweetCreateResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ delete_tweet_by_id } \emph{ Tweet delete by Tweet ID }
#' Delete specified Tweet (in the path) by ID.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{TweetDeleteResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : TweetDeleteResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ find_tweet_by_id } \emph{ Tweet lookup by Tweet ID }
#' Returns a variety of information about the Tweet specified by the requested ID.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2TweetsIdResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2TweetsIdResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ find_tweets_by_id } \emph{ Tweet lookup by Tweet IDs }
#' Returns a variety of information about the Tweet specified by the requested ID.
#'
#' \itemize{
#' \item \emph{ @param } ids list( character )
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2TweetsResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2TweetsResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ find_tweets_that_quote_a_tweet } \emph{ Retrieve Tweets that quote a Tweet. }
#' Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } exclude Enum < [replies, retweets] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2TweetsIdQuoteTweetsResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2TweetsIdQuoteTweetsResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_rules } \emph{ Rules lookup }
#' Returns rules from a User's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
#'
#' \itemize{
#' \item \emph{ @param } ids list( character )
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @returnType } \link{RulesLookupResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : RulesLookupResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_tweets_firehose_stream } \emph{ Firehose stream }
#' Streams 100\% of public Tweets.
#'
#' \itemize{
#' \item \emph{ @param } partition integer
#' \item \emph{ @param } backfill_minutes integer
#' \item \emph{ @param } start_time character
#' \item \emph{ @param } end_time character
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{StreamingTweetResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : StreamingTweetResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_tweets_sample10_stream } \emph{ Sample 10\% stream }
#' Streams a deterministic 10\% of public Tweets.
#'
#' \itemize{
#' \item \emph{ @param } partition integer
#' \item \emph{ @param } backfill_minutes integer
#' \item \emph{ @param } start_time character
#' \item \emph{ @param } end_time character
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2TweetsSample10StreamResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2TweetsSample10StreamResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ hide_reply_by_id } \emph{ Hide replies }
#' Hides or unhides a reply to an owned conversation.
#'
#' \itemize{
#' \item \emph{ @param } tweet_id character
#' \item \emph{ @param } tweet_hide_request \link{TweetHideRequest}
#' \item \emph{ @returnType } \link{TweetHideResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : TweetHideResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ lists_id_tweets } \emph{ List Tweets timeline by List ID. }
#' Returns a list of Tweets associated with the provided List ID.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2ListsIdTweetsResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2ListsIdTweetsResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ sample_stream } \emph{ Sample stream }
#' Streams a deterministic 1\% of public Tweets.
#'
#' \itemize{
#' \item \emph{ @param } backfill_minutes integer
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{StreamingTweetResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : StreamingTweetResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ search_stream } \emph{ Filtered stream }
#' Streams Tweets matching the stream's active rule set.
#'
#' \itemize{
#' \item \emph{ @param } backfill_minutes integer
#' \item \emph{ @param } start_time character
#' \item \emph{ @param } end_time character
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{FilteredStreamingTweetResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : FilteredStreamingTweetResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ space_buyers } \emph{ Retrieve the list of Users who purchased a ticket to the given space }
#' Retrieves the list of Users who purchased a ticket to the given space
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } expansions Enum < [pinned_tweet_id] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @returnType } \link{Get2SpacesIdBuyersResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2SpacesIdBuyersResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ space_tweets } \emph{ Retrieve Tweets from a Space. }
#' Retrieves Tweets shared in the specified Space.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2SpacesIdTweetsResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2SpacesIdTweetsResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ tweet_counts_full_archive_search } \emph{ Full archive search counts }
#' Returns Tweet Counts that match a search query.
#'
#' \itemize{
#' \item \emph{ @param } query character
#' \item \emph{ @param } start_time character
#' \item \emph{ @param } end_time character
#' \item \emph{ @param } since_id character
#' \item \emph{ @param } until_id character
#' \item \emph{ @param } next_token character
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } granularity Enum < [minute, hour, day] >
#' \item \emph{ @param } search_count_fields Enum < [end, start, tweet_count] >
#' \item \emph{ @returnType } \link{Get2TweetsCountsAllResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2TweetsCountsAllResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ tweet_counts_recent_search } \emph{ Recent search counts }
#' Returns Tweet Counts from the last 7 days that match a search query.
#'
#' \itemize{
#' \item \emph{ @param } query character
#' \item \emph{ @param } start_time character
#' \item \emph{ @param } end_time character
#' \item \emph{ @param } since_id character
#' \item \emph{ @param } until_id character
#' \item \emph{ @param } next_token character
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } granularity Enum < [minute, hour, day] >
#' \item \emph{ @param } search_count_fields Enum < [end, start, tweet_count] >
#' \item \emph{ @returnType } \link{Get2TweetsCountsRecentResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2TweetsCountsRecentResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ tweets_fullarchive_search } \emph{ Full-archive search }
#' Returns Tweets that match a search query.
#'
#' \itemize{
#' \item \emph{ @param } query character
#' \item \emph{ @param } start_time character
#' \item \emph{ @param } end_time character
#' \item \emph{ @param } since_id character
#' \item \emph{ @param } until_id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } next_token character
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } sort_order Enum < [recency, relevancy] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2TweetsSearchAllResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2TweetsSearchAllResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ tweets_recent_search } \emph{ Recent search }
#' Returns Tweets from the last 7 days that match a search query.
#'
#' \itemize{
#' \item \emph{ @param } query character
#' \item \emph{ @param } start_time character
#' \item \emph{ @param } end_time character
#' \item \emph{ @param } since_id character
#' \item \emph{ @param } until_id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } next_token character
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } sort_order Enum < [recency, relevancy] >
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2TweetsSearchRecentResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2TweetsSearchRecentResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_like } \emph{ Causes the User (in the path) to like the specified Tweet }
#' Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } users_likes_create_request \link{UsersLikesCreateRequest}
#' \item \emph{ @returnType } \link{UsersLikesCreateResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : UsersLikesCreateResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_liked_tweets } \emph{ Returns Tweet objects liked by the provided User ID }
#' Returns a list of Tweets liked by the provided User ID
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2UsersIdLikedTweetsResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersIdLikedTweetsResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_mentions } \emph{ User mention timeline by User ID }
#' Returns Tweet objects that mention username associated to the provided User ID
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } since_id character
#' \item \emph{ @param } until_id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } start_time character
#' \item \emph{ @param } end_time character
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2UsersIdMentionsResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersIdMentionsResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_retweets } \emph{ Causes the User (in the path) to retweet the specified Tweet. }
#' Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } users_retweets_create_request \link{UsersRetweetsCreateRequest}
#' \item \emph{ @returnType } \link{UsersRetweetsCreateResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : UsersRetweetsCreateResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_timeline } \emph{ User home timeline by User ID }
#' Returns Tweet objects that appears in the provided User ID's home timeline
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } since_id character
#' \item \emph{ @param } until_id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } exclude Enum < [replies, retweets] >
#' \item \emph{ @param } start_time character
#' \item \emph{ @param } end_time character
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2UsersIdTimelinesReverseChronologicalResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersIdTimelinesReverseChronologicalResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_tweets } \emph{ User Tweets timeline by User ID }
#' Returns a list of Tweets authored by the provided User ID
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } since_id character
#' \item \emph{ @param } until_id character
#' \item \emph{ @param } max_results integer
#' \item \emph{ @param } pagination_token character
#' \item \emph{ @param } exclude Enum < [replies, retweets] >
#' \item \emph{ @param } start_time character
#' \item \emph{ @param } end_time character
#' \item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
#' \item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
#' \item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
#' \item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
#' \item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
#' \item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
#' \item \emph{ @returnType } \link{Get2UsersIdTweetsResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : Get2UsersIdTweetsResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_unlike } \emph{ Causes the User (in the path) to unlike the specified Tweet }
#' Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } tweet_id character
#' \item \emph{ @returnType } \link{UsersLikesDeleteResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : UsersLikesDeleteResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ users_id_unretweets } \emph{ Causes the User (in the path) to unretweet the specified Tweet }
#' Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } source_tweet_id character
#' \item \emph{ @returnType } \link{UsersRetweetsDeleteResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | The request has succeeded.
#'
#' \item return type : UsersRetweetsDeleteResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The request has failed.
#'
#' \item return type : Error
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  add_or_delete_rules  ####################
#'
#' library(twitter)
#' var_add_or_delete_rules_request <- AddOrDeleteRulesRequest$new() # AddOrDeleteRulesRequest | 
#' var_dry_run <- "dry_run_example" # character | Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
#'
#' #Add/Delete rules
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$add_or_delete_rules(var_add_or_delete_rules_request, dry_run = var_dry_run, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$add_or_delete_rules(var_add_or_delete_rules_request, dry_run = var_dry_run),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `add_or_delete_rules`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  create_tweet  ####################
#'
#' library(twitter)
#' var_tweet_create_request <- TweetCreateRequest$new() # TweetCreateRequest | 
#'
#' #Creation of a Tweet
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$create_tweet(var_tweet_create_request, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$create_tweet(var_tweet_create_request),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `create_tweet`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  delete_tweet_by_id  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the Tweet to be deleted.
#'
#' #Tweet delete by Tweet ID
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$delete_tweet_by_id(var_id, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$delete_tweet_by_id(var_id),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `delete_tweet_by_id`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  find_tweet_by_id  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | A single Tweet ID.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #Tweet lookup by Tweet ID
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$find_tweet_by_id(var_id, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$find_tweet_by_id(var_id, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `find_tweet_by_id`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  find_tweets_by_id  ####################
#'
#' library(twitter)
#' var_ids <- ["ids_example"] # array[character] | A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #Tweet lookup by Tweet IDs
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$find_tweets_by_id(var_ids, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$find_tweets_by_id(var_ids, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `find_tweets_by_id`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  find_tweets_that_quote_a_tweet  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | A single Tweet ID.
#' var_max_results <- 10 # integer | The maximum number of results to be returned.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get a specified 'page' of results.
#' var_exclude <- ["[\"replies\",\"retweets\"]"] # set[character] | The set of entities to exclude (e.g. 'replies' or 'retweets').
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #Retrieve Tweets that quote a Tweet.
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$find_tweets_that_quote_a_tweet(var_id, max_results = var_max_results, pagination_token = var_pagination_token, exclude = var_exclude, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$find_tweets_that_quote_a_tweet(var_id, max_results = var_max_results, pagination_token = var_pagination_token, exclude = var_exclude, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `find_tweets_that_quote_a_tweet`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  get_rules  ####################
#'
#' library(twitter)
#' var_ids <- ["ids_example"] # array[character] | A comma-separated list of Rule IDs.
#' var_max_results <- 1000 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This value is populated by passing the 'next_token' returned in a request to paginate through results.
#'
#' #Rules lookup
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$get_rules(ids = var_ids, max_results = var_max_results, pagination_token = var_pagination_token, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$get_rules(ids = var_ids, max_results = var_max_results, pagination_token = var_pagination_token),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `get_rules`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  get_tweets_firehose_stream  ####################
#'
#' library(twitter)
#' var_partition <- 56 # integer | The partition number.
#' var_backfill_minutes <- 56 # integer | The number of minutes of backfill requested.
#' var_start_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
#' var_end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #Firehose stream
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$get_tweets_firehose_stream(var_partition, backfill_minutes = var_backfill_minutes, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              # this endpoint supports data streaming via a callback function using the optional `stream_callback` parameter, e.g.
#'              # api_instance$tweets_api$get_tweets_firehose_stream(var_partition, backfill_minutes = var_backfill_minutes, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, stream_callback = function(x){ print(length(x)) }),
#'              
#'              
#'              api_instance$tweets_api$get_tweets_firehose_stream(var_partition, backfill_minutes = var_backfill_minutes, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `get_tweets_firehose_stream`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  get_tweets_sample10_stream  ####################
#'
#' library(twitter)
#' var_partition <- 56 # integer | The partition number.
#' var_backfill_minutes <- 56 # integer | The number of minutes of backfill requested.
#' var_start_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
#' var_end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #Sample 10% stream
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$get_tweets_sample10_stream(var_partition, backfill_minutes = var_backfill_minutes, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              # this endpoint supports data streaming via a callback function using the optional `stream_callback` parameter, e.g.
#'              # api_instance$tweets_api$get_tweets_sample10_stream(var_partition, backfill_minutes = var_backfill_minutes, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, stream_callback = function(x){ print(length(x)) }),
#'              
#'              
#'              api_instance$tweets_api$get_tweets_sample10_stream(var_partition, backfill_minutes = var_backfill_minutes, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `get_tweets_sample10_stream`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  hide_reply_by_id  ####################
#'
#' library(twitter)
#' var_tweet_id <- "tweet_id_example" # character | The ID of the reply that you want to hide or unhide.
#' var_tweet_hide_request <- TweetHideRequest$new() # TweetHideRequest | 
#'
#' #Hide replies
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$hide_reply_by_id(var_tweet_id, tweet_hide_request = var_tweet_hide_request, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$hide_reply_by_id(var_tweet_id, tweet_hide_request = var_tweet_hide_request),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `hide_reply_by_id`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  lists_id_tweets  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the List.
#' var_max_results <- 100 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #List Tweets timeline by List ID.
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$lists_id_tweets(var_id, max_results = var_max_results, pagination_token = var_pagination_token, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$lists_id_tweets(var_id, max_results = var_max_results, pagination_token = var_pagination_token, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `lists_id_tweets`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  sample_stream  ####################
#'
#' library(twitter)
#' var_backfill_minutes <- 56 # integer | The number of minutes of backfill requested.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #Sample stream
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$sample_stream(backfill_minutes = var_backfill_minutes, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              # this endpoint supports data streaming via a callback function using the optional `stream_callback` parameter, e.g.
#'              # api_instance$tweets_api$sample_stream(backfill_minutes = var_backfill_minutes, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, stream_callback = function(x){ print(length(x)) }),
#'              
#'              
#'              api_instance$tweets_api$sample_stream(backfill_minutes = var_backfill_minutes, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `sample_stream`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  search_stream  ####################
#'
#' library(twitter)
#' var_backfill_minutes <- 56 # integer | The number of minutes of backfill requested.
#' var_start_time <- "2021-02-01T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
#' var_end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #Filtered stream
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$search_stream(backfill_minutes = var_backfill_minutes, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              # this endpoint supports data streaming via a callback function using the optional `stream_callback` parameter, e.g.
#'              # api_instance$tweets_api$search_stream(backfill_minutes = var_backfill_minutes, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, stream_callback = function(x){ print(length(x)) }),
#'              
#'              
#'              api_instance$tweets_api$search_stream(backfill_minutes = var_backfill_minutes, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `search_stream`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  space_buyers  ####################
#'
#' library(twitter)
#' var_id <- "1YqKDqWqdPLsV" # character | The ID of the Space to be retrieved.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get a specified 'page' of results.
#' var_max_results <- 100 # integer | The maximum number of results.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#'
#' #Retrieve the list of Users who purchased a ticket to the given space
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$space_buyers(var_id, pagination_token = var_pagination_token, max_results = var_max_results, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$space_buyers(var_id, pagination_token = var_pagination_token, max_results = var_max_results, user_fields = var_user_fields, expansions = var_expansions, tweet_fields = var_tweet_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `space_buyers`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  space_tweets  ####################
#'
#' library(twitter)
#' var_id <- "1YqKDqWqdPLsV" # character | The ID of the Space to be retrieved.
#' var_max_results <- 100 # integer | The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #Retrieve Tweets from a Space.
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$space_tweets(var_id, max_results = var_max_results, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$space_tweets(var_id, max_results = var_max_results, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `space_tweets`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  tweet_counts_full_archive_search  ####################
#'
#' library(twitter)
#' var_query <- "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet" # character | One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
#' var_start_time <- "start_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
#' var_end_time <- "end_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
#' var_since_id <- "since_id_example" # character | Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
#' var_until_id <- "until_id_example" # character | Returns results with a Tweet ID less than (that is, older than) the specified ID.
#' var_next_token <- "next_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
#' var_granularity <- "hour" # character | The granularity for the search counts results.
#' var_search_count_fields <- ["[\"end\",\"start\",\"tweet_count\"]"] # set[character] | A comma separated list of SearchCount fields to display.
#'
#' #Full archive search counts
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$tweet_counts_full_archive_search(var_query, start_time = var_start_time, end_time = var_end_time, since_id = var_since_id, until_id = var_until_id, next_token = var_next_token, pagination_token = var_pagination_token, granularity = var_granularity, search_count_fields = var_search_count_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$tweet_counts_full_archive_search(var_query, start_time = var_start_time, end_time = var_end_time, since_id = var_since_id, until_id = var_until_id, next_token = var_next_token, pagination_token = var_pagination_token, granularity = var_granularity, search_count_fields = var_search_count_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `tweet_counts_full_archive_search`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  tweet_counts_recent_search  ####################
#'
#' library(twitter)
#' var_query <- "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet" # character | One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
#' var_start_time <- "start_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
#' var_end_time <- "end_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
#' var_since_id <- "since_id_example" # character | Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
#' var_until_id <- "until_id_example" # character | Returns results with a Tweet ID less than (that is, older than) the specified ID.
#' var_next_token <- "next_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
#' var_granularity <- "hour" # character | The granularity for the search counts results.
#' var_search_count_fields <- ["[\"end\",\"start\",\"tweet_count\"]"] # set[character] | A comma separated list of SearchCount fields to display.
#'
#' #Recent search counts
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$tweet_counts_recent_search(var_query, start_time = var_start_time, end_time = var_end_time, since_id = var_since_id, until_id = var_until_id, next_token = var_next_token, pagination_token = var_pagination_token, granularity = var_granularity, search_count_fields = var_search_count_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$tweet_counts_recent_search(var_query, start_time = var_start_time, end_time = var_end_time, since_id = var_since_id, until_id = var_until_id, next_token = var_next_token, pagination_token = var_pagination_token, granularity = var_granularity, search_count_fields = var_search_count_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `tweet_counts_recent_search`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  tweets_fullarchive_search  ####################
#'
#' library(twitter)
#' var_query <- "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet" # character | One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
#' var_start_time <- "start_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
#' var_end_time <- "end_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
#' var_since_id <- "since_id_example" # character | Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
#' var_until_id <- "until_id_example" # character | Returns results with a Tweet ID less than (that is, older than) the specified ID.
#' var_max_results <- 10 # integer | The maximum number of search results to be returned by a request.
#' var_next_token <- "next_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
#' var_sort_order <- "sort_order_example" # character | This order in which to return results.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #Full-archive search
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$tweets_fullarchive_search(var_query, start_time = var_start_time, end_time = var_end_time, since_id = var_since_id, until_id = var_until_id, max_results = var_max_results, next_token = var_next_token, pagination_token = var_pagination_token, sort_order = var_sort_order, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$tweets_fullarchive_search(var_query, start_time = var_start_time, end_time = var_end_time, since_id = var_since_id, until_id = var_until_id, max_results = var_max_results, next_token = var_next_token, pagination_token = var_pagination_token, sort_order = var_sort_order, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `tweets_fullarchive_search`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  tweets_recent_search  ####################
#'
#' library(twitter)
#' var_query <- "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet" # character | One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
#' var_start_time <- "start_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
#' var_end_time <- "end_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
#' var_since_id <- "since_id_example" # character | Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
#' var_until_id <- "until_id_example" # character | Returns results with a Tweet ID less than (that is, older than) the specified ID.
#' var_max_results <- 10 # integer | The maximum number of search results to be returned by a request.
#' var_next_token <- "next_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
#' var_sort_order <- "sort_order_example" # character | This order in which to return results.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #Recent search
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$tweets_recent_search(var_query, start_time = var_start_time, end_time = var_end_time, since_id = var_since_id, until_id = var_until_id, max_results = var_max_results, next_token = var_next_token, pagination_token = var_pagination_token, sort_order = var_sort_order, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$tweets_recent_search(var_query, start_time = var_start_time, end_time = var_end_time, since_id = var_since_id, until_id = var_until_id, max_results = var_max_results, next_token = var_next_token, pagination_token = var_pagination_token, sort_order = var_sort_order, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `tweets_recent_search`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_like  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the authenticated source User that is requesting to like the Tweet.
#' var_users_likes_create_request <- UsersLikesCreateRequest$new() # UsersLikesCreateRequest | 
#'
#' #Causes the User (in the path) to like the specified Tweet
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$users_id_like(var_id, users_likes_create_request = var_users_likes_create_request, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$users_id_like(var_id, users_likes_create_request = var_users_likes_create_request),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_like`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_liked_tweets  ####################
#'
#' library(twitter)
#' var_id <- "2244994945" # character | The ID of the User to lookup.
#' var_max_results <- 56 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #Returns Tweet objects liked by the provided User ID
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$users_id_liked_tweets(var_id, max_results = var_max_results, pagination_token = var_pagination_token, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$users_id_liked_tweets(var_id, max_results = var_max_results, pagination_token = var_pagination_token, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_liked_tweets`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_mentions  ####################
#'
#' library(twitter)
#' var_id <- "2244994945" # character | The ID of the User to lookup.
#' var_since_id <- "since_id_example" # character | The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
#' var_until_id <- "1346889436626259968" # character | The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
#' var_max_results <- 56 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
#' var_start_time <- "2021-02-01T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
#' var_end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #User mention timeline by User ID
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$users_id_mentions(var_id, since_id = var_since_id, until_id = var_until_id, max_results = var_max_results, pagination_token = var_pagination_token, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$users_id_mentions(var_id, since_id = var_since_id, until_id = var_until_id, max_results = var_max_results, pagination_token = var_pagination_token, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_mentions`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_retweets  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the authenticated source User that is requesting to retweet the Tweet.
#' var_users_retweets_create_request <- UsersRetweetsCreateRequest$new() # UsersRetweetsCreateRequest | 
#'
#' #Causes the User (in the path) to retweet the specified Tweet.
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$users_id_retweets(var_id, users_retweets_create_request = var_users_retweets_create_request, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$users_id_retweets(var_id, users_retweets_create_request = var_users_retweets_create_request),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_retweets`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_timeline  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.
#' var_since_id <- "791775337160081409" # character | The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
#' var_until_id <- "1346889436626259968" # character | The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
#' var_max_results <- 56 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
#' var_exclude <- ["[\"replies\",\"retweets\"]"] # set[character] | The set of entities to exclude (e.g. 'replies' or 'retweets').
#' var_start_time <- "2021-02-01T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
#' var_end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #User home timeline by User ID
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$users_id_timeline(var_id, since_id = var_since_id, until_id = var_until_id, max_results = var_max_results, pagination_token = var_pagination_token, exclude = var_exclude, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$users_id_timeline(var_id, since_id = var_since_id, until_id = var_until_id, max_results = var_max_results, pagination_token = var_pagination_token, exclude = var_exclude, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_timeline`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_tweets  ####################
#'
#' library(twitter)
#' var_id <- "2244994945" # character | The ID of the User to lookup.
#' var_since_id <- "791775337160081409" # character | The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
#' var_until_id <- "1346889436626259968" # character | The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
#' var_max_results <- 56 # integer | The maximum number of results.
#' var_pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
#' var_exclude <- ["[\"replies\",\"retweets\"]"] # set[character] | The set of entities to exclude (e.g. 'replies' or 'retweets').
#' var_start_time <- "2021-02-01T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
#' var_end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
#' var_tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
#' var_expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
#' var_media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
#' var_poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
#' var_user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
#' var_place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.
#'
#' #User Tweets timeline by User ID
#' api_instance <- twitter_api$new()
#'
#' # Configure HTTP bearer authorization: BearerToken
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$users_id_tweets(var_id, since_id = var_since_id, until_id = var_until_id, max_results = var_max_results, pagination_token = var_pagination_token, exclude = var_exclude, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$users_id_tweets(var_id, since_id = var_since_id, until_id = var_until_id, max_results = var_max_results, pagination_token = var_pagination_token, exclude = var_exclude, start_time = var_start_time, end_time = var_end_time, tweet_fields = var_tweet_fields, expansions = var_expansions, media_fields = var_media_fields, poll_fields = var_poll_fields, user_fields = var_user_fields, place_fields = var_place_fields),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_tweets`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_unlike  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the authenticated source User that is requesting to unlike the Tweet.
#' var_tweet_id <- "tweet_id_example" # character | The ID of the Tweet that the User is requesting to unlike.
#'
#' #Causes the User (in the path) to unlike the specified Tweet
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$users_id_unlike(var_id, var_tweet_id, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$users_id_unlike(var_id, var_tweet_id),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_unlike`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' ####################  users_id_unretweets  ####################
#'
#' library(twitter)
#' var_id <- "id_example" # character | The ID of the authenticated source User that is requesting to retweet the Tweet.
#' var_source_tweet_id <- "source_tweet_id_example" # character | The ID of the Tweet that the User is requesting to unretweet.
#'
#' #Causes the User (in the path) to unretweet the specified Tweet
#' api_instance <- twitter_api$new()
#'
#' # Configure OAuth2 access token for authorization: OAuth2UserToken
#' api_instance$api_client$access_token <- Sys.getenv("ACCESS_TOKEN")
#'
#'
#' result <- tryCatch(
#'              
#'              # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#'              # api_instance$tweets_api$users_id_unretweets(var_id, var_source_tweet_id, data_file = "result.txt"),
#'              
#'              
#'              api_instance$tweets_api$users_id_unretweets(var_id, var_source_tweet_id),
#'              ApiException = function(ex) ex
#'           )
#' # In case of error, print the error object
#' if (!is.null(result$ApiException)) {
#'   print("Exception occurs when calling `users_id_unretweets`:")
#'   dput(result$ApiException$toString())
#'   
#'   # error object
#'   dput(result$ApiException$error_object$toJSONString())
#'   
#' } else {
#'   # deserialized response object
#'   print("The response is ...")
#'   dput(result$toString())
#' }
#'
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @importFrom rlang abort
#' @export
TweetsApi <- R6::R6Class(
  "TweetsApi",
  public = list(
    api_client = NULL,
    #' Initialize a new TweetsApi.
    #'
    #' @description
    #' Initialize a new TweetsApi.
    #'
    #' @param api_client An instance of API client.
    #' @export
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },
    #' Add/Delete rules
    #'
    #' @description
    #' Add/Delete rules
    #'
    #' @param add_or_delete_rules_request 
    #' @param dry_run (optional) Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return AddOrDeleteRulesResponse
    #' @export
    add_or_delete_rules = function(add_or_delete_rules_request, dry_run = NULL, data_file = NULL, ...) {
      local_var_response <- self$add_or_delete_rules_with_http_info(add_or_delete_rules_request, dry_run, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Add/Delete rules
    #'
    #' @description
    #' Add/Delete rules
    #'
    #' @param add_or_delete_rules_request 
    #' @param dry_run (optional) Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (AddOrDeleteRulesResponse) with additional information such as HTTP status code, headers
    #' @export
    add_or_delete_rules_with_http_info = function(add_or_delete_rules_request, dry_run = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`add_or_delete_rules_request`)) {
        rlang::abort(message = "Missing required parameter `add_or_delete_rules_request`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `add_or_delete_rules_request`."))
      }



      query_params[["dry_run"]] <- `dry_run`

      if (!is.null(`add_or_delete_rules_request`)) {
        local_var_body <- `add_or_delete_rules_request`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/2/tweets/search/stream/rules"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "AddOrDeleteRulesResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Creation of a Tweet
    #'
    #' @description
    #' Creation of a Tweet
    #'
    #' @param tweet_create_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return TweetCreateResponse
    #' @export
    create_tweet = function(tweet_create_request, data_file = NULL, ...) {
      local_var_response <- self$create_tweet_with_http_info(tweet_create_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Creation of a Tweet
    #'
    #' @description
    #' Creation of a Tweet
    #'
    #' @param tweet_create_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (TweetCreateResponse) with additional information such as HTTP status code, headers
    #' @export
    create_tweet_with_http_info = function(tweet_create_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`tweet_create_request`)) {
        rlang::abort(message = "Missing required parameter `tweet_create_request`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `tweet_create_request`."))
      }


      if (!is.null(`tweet_create_request`)) {
        local_var_body <- `tweet_create_request`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/2/tweets"
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read tweet.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "TweetCreateResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Tweet delete by Tweet ID
    #'
    #' @description
    #' Tweet delete by Tweet ID
    #'
    #' @param id The ID of the Tweet to be deleted.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return TweetDeleteResponse
    #' @export
    delete_tweet_by_id = function(id, data_file = NULL, ...) {
      local_var_response <- self$delete_tweet_by_id_with_http_info(id, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Tweet delete by Tweet ID
    #'
    #' @description
    #' Tweet delete by Tweet ID
    #'
    #' @param id The ID of the Tweet to be deleted.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (TweetDeleteResponse) with additional information such as HTTP status code, headers
    #' @export
    delete_tweet_by_id_with_http_info = function(id, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling TweetsApi$delete_tweet_by_id, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling TweetsApi$delete_tweet_by_id, must conform to the pattern ^[0-9]{1,19}$."))
      }

      local_var_url_path <- "/2/tweets/{id}"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read tweet.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "DELETE",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "TweetDeleteResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Tweet lookup by Tweet ID
    #'
    #' @description
    #' Tweet lookup by Tweet ID
    #'
    #' @param id A single Tweet ID.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2TweetsIdResponse
    #' @export
    find_tweet_by_id = function(id, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$find_tweet_by_id_with_http_info(id, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Tweet lookup by Tweet ID
    #'
    #' @description
    #' Tweet lookup by Tweet ID
    #'
    #' @param id A single Tweet ID.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2TweetsIdResponse) with additional information such as HTTP status code, headers
    #' @export
    find_tweet_by_id_with_http_info = function(id, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling TweetsApi$find_tweet_by_id, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling TweetsApi$find_tweet_by_id, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$find_tweet_by_id, number of items must be greater than or equal to 1."))
      }

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweet_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweet_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweet_by_id. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweet_by_id. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$find_tweet_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$find_tweet_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$find_tweet_by_id. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$find_tweet_by_id. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$find_tweet_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$find_tweet_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$find_tweet_by_id. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$find_tweet_by_id. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$find_tweet_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$find_tweet_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$find_tweet_by_id. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$find_tweet_by_id. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$find_tweet_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$find_tweet_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$find_tweet_by_id. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$find_tweet_by_id. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$find_tweet_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$find_tweet_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$find_tweet_by_id. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$find_tweet_by_id. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/{id}"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2TweetsIdResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Tweet lookup by Tweet IDs
    #'
    #' @description
    #' Tweet lookup by Tweet IDs
    #'
    #' @param ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2TweetsResponse
    #' @export
    find_tweets_by_id = function(ids, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$find_tweets_by_id_with_http_info(ids, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Tweet lookup by Tweet IDs
    #'
    #' @description
    #' Tweet lookup by Tweet IDs
    #'
    #' @param ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2TweetsResponse) with additional information such as HTTP status code, headers
    #' @export
    find_tweets_by_id_with_http_info = function(ids, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`ids`)) {
        rlang::abort(message = "Missing required parameter `ids`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `ids`."))
      }

      if (length(`ids`) > 100) {
        rlang::abort(message = "Invalid length for `ids` when calling TweetsApi$find_tweets_by_id, number of items must be less than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `ids` when calling TweetsApi$find_tweets_by_id, number of items must be less than or equal to 100."))
      }
      if (length(`ids`) < 1) {
        rlang::abort(message = "Invalid length for `ids` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `ids` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$find_tweets_by_id, number of items must be greater than or equal to 1."))
      }

      # no explore
      query_params[["ids"]] <- I(paste(lapply(`ids`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweets_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweets_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweets_by_id. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweets_by_id. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$find_tweets_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$find_tweets_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$find_tweets_by_id. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$find_tweets_by_id. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$find_tweets_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$find_tweets_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$find_tweets_by_id. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$find_tweets_by_id. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$find_tweets_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$find_tweets_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$find_tweets_by_id. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$find_tweets_by_id. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$find_tweets_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$find_tweets_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$find_tweets_by_id. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$find_tweets_by_id. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$find_tweets_by_id. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$find_tweets_by_id. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$find_tweets_by_id. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$find_tweets_by_id. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2TweetsResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Retrieve Tweets that quote a Tweet.
    #'
    #' @description
    #' Retrieve Tweets that quote a Tweet.
    #'
    #' @param id A single Tweet ID.
    #' @param max_results (optional) The maximum number of results to be returned. (default value: 10)
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param exclude (optional) The set of entities to exclude (e.g. 'replies' or 'retweets').
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2TweetsIdQuoteTweetsResponse
    #' @export
    find_tweets_that_quote_a_tweet = function(id, max_results = 10, pagination_token = NULL, exclude = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$find_tweets_that_quote_a_tweet_with_http_info(id, max_results, pagination_token, exclude, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve Tweets that quote a Tweet.
    #'
    #' @description
    #' Retrieve Tweets that quote a Tweet.
    #'
    #' @param id A single Tweet ID.
    #' @param max_results (optional) The maximum number of results to be returned. (default value: 10)
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param exclude (optional) The set of entities to exclude (e.g. 'replies' or 'retweets').
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2TweetsIdQuoteTweetsResponse) with additional information such as HTTP status code, headers
    #' @export
    find_tweets_that_quote_a_tweet_with_http_info = function(id, max_results = 10, pagination_token = NULL, exclude = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling TweetsApi$find_tweets_that_quote_a_tweet, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling TweetsApi$find_tweets_that_quote_a_tweet, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$find_tweets_that_quote_a_tweet, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$find_tweets_that_quote_a_tweet, must be smaller than or equal to 100."))
      }
      if (`max_results` < 10) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$find_tweets_that_quote_a_tweet, must be bigger than or equal to 10.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$find_tweets_that_quote_a_tweet, must be bigger than or equal to 10."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$find_tweets_that_quote_a_tweet, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$find_tweets_that_quote_a_tweet, must be bigger than or equal to 1."))
      }

      if (length(`exclude`) < 1) {
        rlang::abort(message = "Invalid length for `exclude` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `exclude` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`exclude`, unique(`exclude`))) {
        rlang::abort(message = "Invalid value for `exclude` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `exclude` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `exclude`) {
        if (!(query_item %in% c("replies", "retweets"))) {
          rlang::abort(message = "Invalid value for `exclude` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [replies, retweets].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `exclude` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [replies, retweets]."))
        }
      }
      query_params[["exclude"]] <- I(paste(lapply(`exclude`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$find_tweets_that_quote_a_tweet. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/{id}/quote_tweets"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2TweetsIdQuoteTweetsResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Rules lookup
    #'
    #' @description
    #' Rules lookup
    #'
    #' @param ids (optional) A comma-separated list of Rule IDs.
    #' @param max_results (optional) The maximum number of results. (default value: 1000)
    #' @param pagination_token (optional) This value is populated by passing the 'next_token' returned in a request to paginate through results.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return RulesLookupResponse
    #' @export
    get_rules = function(ids = NULL, max_results = 1000, pagination_token = NULL, data_file = NULL, ...) {
      local_var_response <- self$get_rules_with_http_info(ids, max_results, pagination_token, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Rules lookup
    #'
    #' @description
    #' Rules lookup
    #'
    #' @param ids (optional) A comma-separated list of Rule IDs.
    #' @param max_results (optional) The maximum number of results. (default value: 1000)
    #' @param pagination_token (optional) This value is populated by passing the 'next_token' returned in a request to paginate through results.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (RulesLookupResponse) with additional information such as HTTP status code, headers
    #' @export
    get_rules_with_http_info = function(ids = NULL, max_results = 1000, pagination_token = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE


      if (`max_results` > 1000) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$get_rules, must be smaller than or equal to 1000.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$get_rules, must be smaller than or equal to 1000."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$get_rules, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$get_rules, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) > 16) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$get_rules, must be smaller than or equal to 16.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for $pagination_token when calling TweetsApi.get_rules, must be smaller than or equal to 16."))
      }
      if (nchar(`pagination_token`) < 16) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$get_rules, must be bigger than or equal to 16.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$get_rules, must be bigger than or equal to 16."))
      }

      # explore
      for (query_item in `ids`) {
        query_params[["ids"]] <- c(query_params[["ids"]], list(`ids` = query_item))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      local_var_url_path <- "/2/tweets/search/stream/rules"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "RulesLookupResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Firehose stream
    #'
    #' @description
    #' Firehose stream
    #'
    #' @param partition The partition number.
    #' @param backfill_minutes (optional) The number of minutes of backfill requested.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param stream_callback (optional) callback function to process the data stream
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return StreamingTweetResponse
    #' @export
    get_tweets_firehose_stream = function(partition, backfill_minutes = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, stream_callback = NULL, data_file = NULL, ...) {
      local_var_response <- self$get_tweets_firehose_stream_with_http_info(partition, backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, stream_callback = stream_callback, data_file = data_file, ...)
      if (typeof(stream_callback) == "closure") { # return void if streaming is enabled
        return(invisible(NULL))
      }

      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Firehose stream
    #'
    #' @description
    #' Firehose stream
    #'
    #' @param partition The partition number.
    #' @param backfill_minutes (optional) The number of minutes of backfill requested.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param stream_callback (optional) callback function to process the data stream
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (StreamingTweetResponse) with additional information such as HTTP status code, headers
    #' @export
    get_tweets_firehose_stream_with_http_info = function(partition, backfill_minutes = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, stream_callback = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`partition`)) {
        rlang::abort(message = "Missing required parameter `partition`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `partition`."))
      }

      if (`partition` > 20) {
        rlang::abort(message = "Invalid value for `partition` when calling TweetsApi$get_tweets_firehose_stream, must be smaller than or equal to 20.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `partition` when calling TweetsApi$get_tweets_firehose_stream, must be smaller than or equal to 20."))
      }
      if (`partition` < 1) {
        rlang::abort(message = "Invalid value for `partition` when calling TweetsApi$get_tweets_firehose_stream, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `partition` when calling TweetsApi$get_tweets_firehose_stream, must be bigger than or equal to 1."))
      }

      if (`backfill_minutes` > 5) {
        rlang::abort(message = "Invalid value for `backfill_minutes` when calling TweetsApi$get_tweets_firehose_stream, must be smaller than or equal to 5.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `backfill_minutes` when calling TweetsApi$get_tweets_firehose_stream, must be smaller than or equal to 5."))
      }
      if (`backfill_minutes` < 0) {
        rlang::abort(message = "Invalid value for `backfill_minutes` when calling TweetsApi$get_tweets_firehose_stream, must be bigger than or equal to 0.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `backfill_minutes` when calling TweetsApi$get_tweets_firehose_stream, must be bigger than or equal to 0."))
      }



      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$get_tweets_firehose_stream, number of items must be greater than or equal to 1."))
      }

      query_params[["backfill_minutes"]] <- `backfill_minutes`

      query_params[["partition"]] <- `partition`

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$get_tweets_firehose_stream. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$get_tweets_firehose_stream. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$get_tweets_firehose_stream. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$get_tweets_firehose_stream. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$get_tweets_firehose_stream. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$get_tweets_firehose_stream. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$get_tweets_firehose_stream. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$get_tweets_firehose_stream. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$get_tweets_firehose_stream. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$get_tweets_firehose_stream. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$get_tweets_firehose_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$get_tweets_firehose_stream. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$get_tweets_firehose_stream. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/firehose/stream"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 stream_callback = stream_callback,
                                 ...)

      if (typeof(stream_callback) == "closure") { # return void if streaming is enabled
        return(invisible(NULL))
      }

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "StreamingTweetResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Sample 10% stream
    #'
    #' @description
    #' Sample 10% stream
    #'
    #' @param partition The partition number.
    #' @param backfill_minutes (optional) The number of minutes of backfill requested.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param stream_callback (optional) callback function to process the data stream
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2TweetsSample10StreamResponse
    #' @export
    get_tweets_sample10_stream = function(partition, backfill_minutes = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, stream_callback = NULL, data_file = NULL, ...) {
      local_var_response <- self$get_tweets_sample10_stream_with_http_info(partition, backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, stream_callback = stream_callback, data_file = data_file, ...)
      if (typeof(stream_callback) == "closure") { # return void if streaming is enabled
        return(invisible(NULL))
      }

      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Sample 10% stream
    #'
    #' @description
    #' Sample 10% stream
    #'
    #' @param partition The partition number.
    #' @param backfill_minutes (optional) The number of minutes of backfill requested.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param stream_callback (optional) callback function to process the data stream
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2TweetsSample10StreamResponse) with additional information such as HTTP status code, headers
    #' @export
    get_tweets_sample10_stream_with_http_info = function(partition, backfill_minutes = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, stream_callback = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`partition`)) {
        rlang::abort(message = "Missing required parameter `partition`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `partition`."))
      }

      if (`partition` > 2) {
        rlang::abort(message = "Invalid value for `partition` when calling TweetsApi$get_tweets_sample10_stream, must be smaller than or equal to 2.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `partition` when calling TweetsApi$get_tweets_sample10_stream, must be smaller than or equal to 2."))
      }
      if (`partition` < 1) {
        rlang::abort(message = "Invalid value for `partition` when calling TweetsApi$get_tweets_sample10_stream, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `partition` when calling TweetsApi$get_tweets_sample10_stream, must be bigger than or equal to 1."))
      }

      if (`backfill_minutes` > 5) {
        rlang::abort(message = "Invalid value for `backfill_minutes` when calling TweetsApi$get_tweets_sample10_stream, must be smaller than or equal to 5.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `backfill_minutes` when calling TweetsApi$get_tweets_sample10_stream, must be smaller than or equal to 5."))
      }
      if (`backfill_minutes` < 0) {
        rlang::abort(message = "Invalid value for `backfill_minutes` when calling TweetsApi$get_tweets_sample10_stream, must be bigger than or equal to 0.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `backfill_minutes` when calling TweetsApi$get_tweets_sample10_stream, must be bigger than or equal to 0."))
      }



      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$get_tweets_sample10_stream, number of items must be greater than or equal to 1."))
      }

      query_params[["backfill_minutes"]] <- `backfill_minutes`

      query_params[["partition"]] <- `partition`

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$get_tweets_sample10_stream. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$get_tweets_sample10_stream. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$get_tweets_sample10_stream. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$get_tweets_sample10_stream. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$get_tweets_sample10_stream. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$get_tweets_sample10_stream. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$get_tweets_sample10_stream. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$get_tweets_sample10_stream. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$get_tweets_sample10_stream. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$get_tweets_sample10_stream. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$get_tweets_sample10_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$get_tweets_sample10_stream. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$get_tweets_sample10_stream. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/sample10/stream"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 stream_callback = stream_callback,
                                 ...)

      if (typeof(stream_callback) == "closure") { # return void if streaming is enabled
        return(invisible(NULL))
      }

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2TweetsSample10StreamResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Hide replies
    #'
    #' @description
    #' Hide replies
    #'
    #' @param tweet_id The ID of the reply that you want to hide or unhide.
    #' @param tweet_hide_request (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return TweetHideResponse
    #' @export
    hide_reply_by_id = function(tweet_id, tweet_hide_request = NULL, data_file = NULL, ...) {
      local_var_response <- self$hide_reply_by_id_with_http_info(tweet_id, tweet_hide_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Hide replies
    #'
    #' @description
    #' Hide replies
    #'
    #' @param tweet_id The ID of the reply that you want to hide or unhide.
    #' @param tweet_hide_request (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (TweetHideResponse) with additional information such as HTTP status code, headers
    #' @export
    hide_reply_by_id_with_http_info = function(tweet_id, tweet_hide_request = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`tweet_id`)) {
        rlang::abort(message = "Missing required parameter `tweet_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `tweet_id`."))
      }

      if (!str_detect(`tweet_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `tweet_id` when calling TweetsApi$hide_reply_by_id, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_id` when calling TweetsApi$hide_reply_by_id, must conform to the pattern ^[0-9]{1,19}$."))
      }


      if (!is.null(`tweet_hide_request`)) {
        local_var_body <- `tweet_hide_request`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/2/tweets/{tweet_id}/hidden"
      if (!missing(`tweet_id`)) {
        local_var_url_path <- gsub("\\{tweet_id\\}", URLencode(as.character(`tweet_id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read tweet.moderate.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "PUT",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "TweetHideResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' List Tweets timeline by List ID.
    #'
    #' @description
    #' List Tweets timeline by List ID.
    #'
    #' @param id The ID of the List.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2ListsIdTweetsResponse
    #' @export
    lists_id_tweets = function(id, max_results = 100, pagination_token = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$lists_id_tweets_with_http_info(id, max_results, pagination_token, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' List Tweets timeline by List ID.
    #'
    #' @description
    #' List Tweets timeline by List ID.
    #'
    #' @param id The ID of the List.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2ListsIdTweetsResponse) with additional information such as HTTP status code, headers
    #' @export
    lists_id_tweets_with_http_info = function(id, max_results = 100, pagination_token = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling TweetsApi$lists_id_tweets, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling TweetsApi$lists_id_tweets, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$lists_id_tweets, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$lists_id_tweets, must be smaller than or equal to 100."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$lists_id_tweets, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$lists_id_tweets, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$lists_id_tweets, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$lists_id_tweets, must be bigger than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$lists_id_tweets, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$lists_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$lists_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$lists_id_tweets. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$lists_id_tweets. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$lists_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$lists_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$lists_id_tweets. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$lists_id_tweets. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$lists_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$lists_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$lists_id_tweets. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$lists_id_tweets. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$lists_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$lists_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$lists_id_tweets. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$lists_id_tweets. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$lists_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$lists_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$lists_id_tweets. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$lists_id_tweets. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$lists_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$lists_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$lists_id_tweets. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$lists_id_tweets. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/lists/{id}/tweets"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read list.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2ListsIdTweetsResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Sample stream
    #'
    #' @description
    #' Sample stream
    #'
    #' @param backfill_minutes (optional) The number of minutes of backfill requested.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param stream_callback (optional) callback function to process the data stream
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return StreamingTweetResponse
    #' @export
    sample_stream = function(backfill_minutes = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, stream_callback = NULL, data_file = NULL, ...) {
      local_var_response <- self$sample_stream_with_http_info(backfill_minutes, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, stream_callback = stream_callback, data_file = data_file, ...)
      if (typeof(stream_callback) == "closure") { # return void if streaming is enabled
        return(invisible(NULL))
      }

      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Sample stream
    #'
    #' @description
    #' Sample stream
    #'
    #' @param backfill_minutes (optional) The number of minutes of backfill requested.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param stream_callback (optional) callback function to process the data stream
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (StreamingTweetResponse) with additional information such as HTTP status code, headers
    #' @export
    sample_stream_with_http_info = function(backfill_minutes = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, stream_callback = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (`backfill_minutes` > 5) {
        rlang::abort(message = "Invalid value for `backfill_minutes` when calling TweetsApi$sample_stream, must be smaller than or equal to 5.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `backfill_minutes` when calling TweetsApi$sample_stream, must be smaller than or equal to 5."))
      }
      if (`backfill_minutes` < 0) {
        rlang::abort(message = "Invalid value for `backfill_minutes` when calling TweetsApi$sample_stream, must be bigger than or equal to 0.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `backfill_minutes` when calling TweetsApi$sample_stream, must be bigger than or equal to 0."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$sample_stream, number of items must be greater than or equal to 1."))
      }

      query_params[["backfill_minutes"]] <- `backfill_minutes`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$sample_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$sample_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$sample_stream. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$sample_stream. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$sample_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$sample_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$sample_stream. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$sample_stream. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$sample_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$sample_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$sample_stream. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$sample_stream. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$sample_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$sample_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$sample_stream. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$sample_stream. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$sample_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$sample_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$sample_stream. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$sample_stream. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$sample_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$sample_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$sample_stream. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$sample_stream. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/sample/stream"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 stream_callback = stream_callback,
                                 ...)

      if (typeof(stream_callback) == "closure") { # return void if streaming is enabled
        return(invisible(NULL))
      }

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "StreamingTweetResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Filtered stream
    #'
    #' @description
    #' Filtered stream
    #'
    #' @param backfill_minutes (optional) The number of minutes of backfill requested.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param stream_callback (optional) callback function to process the data stream
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return FilteredStreamingTweetResponse
    #' @export
    search_stream = function(backfill_minutes = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, stream_callback = NULL, data_file = NULL, ...) {
      local_var_response <- self$search_stream_with_http_info(backfill_minutes, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, stream_callback = stream_callback, data_file = data_file, ...)
      if (typeof(stream_callback) == "closure") { # return void if streaming is enabled
        return(invisible(NULL))
      }

      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Filtered stream
    #'
    #' @description
    #' Filtered stream
    #'
    #' @param backfill_minutes (optional) The number of minutes of backfill requested.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param stream_callback (optional) callback function to process the data stream
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (FilteredStreamingTweetResponse) with additional information such as HTTP status code, headers
    #' @export
    search_stream_with_http_info = function(backfill_minutes = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, stream_callback = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (`backfill_minutes` > 5) {
        rlang::abort(message = "Invalid value for `backfill_minutes` when calling TweetsApi$search_stream, must be smaller than or equal to 5.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `backfill_minutes` when calling TweetsApi$search_stream, must be smaller than or equal to 5."))
      }
      if (`backfill_minutes` < 0) {
        rlang::abort(message = "Invalid value for `backfill_minutes` when calling TweetsApi$search_stream, must be bigger than or equal to 0.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `backfill_minutes` when calling TweetsApi$search_stream, must be bigger than or equal to 0."))
      }



      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$search_stream, number of items must be greater than or equal to 1."))
      }

      query_params[["backfill_minutes"]] <- `backfill_minutes`

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$search_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$search_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$search_stream. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$search_stream. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$search_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$search_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$search_stream. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$search_stream. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$search_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$search_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$search_stream. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$search_stream. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$search_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$search_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$search_stream. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$search_stream. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$search_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$search_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$search_stream. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$search_stream. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$search_stream. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$search_stream. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$search_stream. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$search_stream. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/search/stream"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 stream_callback = stream_callback,
                                 ...)

      if (typeof(stream_callback) == "closure") { # return void if streaming is enabled
        return(invisible(NULL))
      }

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "FilteredStreamingTweetResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Retrieve the list of Users who purchased a ticket to the given space
    #'
    #' @description
    #' Retrieve the list of Users who purchased a ticket to the given space
    #'
    #' @param id The ID of the Space to be retrieved.
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2SpacesIdBuyersResponse
    #' @export
    space_buyers = function(id, pagination_token = NULL, max_results = 100, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$space_buyers_with_http_info(id, pagination_token, max_results, user_fields, expansions, tweet_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the list of Users who purchased a ticket to the given space
    #'
    #' @description
    #' Retrieve the list of Users who purchased a ticket to the given space
    #'
    #' @param id The ID of the Space to be retrieved.
    #' @param pagination_token (optional) This parameter is used to get a specified 'page' of results.
    #' @param max_results (optional) The maximum number of results. (default value: 100)
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2SpacesIdBuyersResponse) with additional information such as HTTP status code, headers
    #' @export
    space_buyers_with_http_info = function(id, pagination_token = NULL, max_results = 100, user_fields = NULL, expansions = NULL, tweet_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[a-zA-Z0-9]{1,13}$")) {
        rlang::abort(message = "Invalid value for `id` when calling TweetsApi$space_buyers, must conform to the pattern ^[a-zA-Z0-9]{1,13}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling TweetsApi$space_buyers, must conform to the pattern ^[a-zA-Z0-9]{1,13}$."))
      }

      if (nchar(`pagination_token`) < 16) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$space_buyers, must be bigger than or equal to 16.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$space_buyers, must be bigger than or equal to 16."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$space_buyers, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$space_buyers, must be smaller than or equal to 100."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$space_buyers, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$space_buyers, must be bigger than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$space_buyers, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$space_buyers, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$space_buyers, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$space_buyers, number of items must be greater than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$space_buyers, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$space_buyers, number of items must be greater than or equal to 1."))
      }

      query_params[["pagination_token"]] <- `pagination_token`

      query_params[["max_results"]] <- `max_results`

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$space_buyers. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$space_buyers. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$space_buyers. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$space_buyers. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$space_buyers. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$space_buyers. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("pinned_tweet_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$space_buyers. Must be [pinned_tweet_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$space_buyers. Must be [pinned_tweet_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$space_buyers. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$space_buyers. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$space_buyers. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$space_buyers. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/spaces/{id}/buyers"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read space.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2SpacesIdBuyersResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Retrieve Tweets from a Space.
    #'
    #' @description
    #' Retrieve Tweets from a Space.
    #'
    #' @param id The ID of the Space to be retrieved.
    #' @param max_results (optional) The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (default value: 100)
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2SpacesIdTweetsResponse
    #' @export
    space_tweets = function(id, max_results = 100, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$space_tweets_with_http_info(id, max_results, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve Tweets from a Space.
    #'
    #' @description
    #' Retrieve Tweets from a Space.
    #'
    #' @param id The ID of the Space to be retrieved.
    #' @param max_results (optional) The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (default value: 100)
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2SpacesIdTweetsResponse) with additional information such as HTTP status code, headers
    #' @export
    space_tweets_with_http_info = function(id, max_results = 100, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[a-zA-Z0-9]{1,13}$")) {
        rlang::abort(message = "Invalid value for `id` when calling TweetsApi$space_tweets, must conform to the pattern ^[a-zA-Z0-9]{1,13}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling TweetsApi$space_tweets, must conform to the pattern ^[a-zA-Z0-9]{1,13}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$space_tweets, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$space_tweets, must be smaller than or equal to 100."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$space_tweets, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$space_tweets, must be bigger than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$space_tweets, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$space_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$space_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$space_tweets. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$space_tweets. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$space_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$space_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$space_tweets. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$space_tweets. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$space_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$space_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$space_tweets. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$space_tweets. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$space_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$space_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$space_tweets. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$space_tweets. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$space_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$space_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$space_tweets. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$space_tweets. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$space_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$space_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$space_tweets. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$space_tweets. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/spaces/{id}/tweets"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read space.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2SpacesIdTweetsResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Full archive search counts
    #'
    #' @description
    #' Full archive search counts
    #'
    #' @param query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    #' @param since_id (optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    #' @param until_id (optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.
    #' @param next_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param granularity (optional) The granularity for the search counts results. (default value: "hour")
    #' @param search_count_fields (optional) A comma separated list of SearchCount fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2TweetsCountsAllResponse
    #' @export
    tweet_counts_full_archive_search = function(query, start_time = NULL, end_time = NULL, since_id = NULL, until_id = NULL, next_token = NULL, pagination_token = NULL, granularity = "hour", search_count_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$tweet_counts_full_archive_search_with_http_info(query, start_time, end_time, since_id, until_id, next_token, pagination_token, granularity, search_count_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Full archive search counts
    #'
    #' @description
    #' Full archive search counts
    #'
    #' @param query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    #' @param since_id (optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    #' @param until_id (optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.
    #' @param next_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param granularity (optional) The granularity for the search counts results. (default value: "hour")
    #' @param search_count_fields (optional) A comma separated list of SearchCount fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2TweetsCountsAllResponse) with additional information such as HTTP status code, headers
    #' @export
    tweet_counts_full_archive_search_with_http_info = function(query, start_time = NULL, end_time = NULL, since_id = NULL, until_id = NULL, next_token = NULL, pagination_token = NULL, granularity = "hour", search_count_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`query`)) {
        rlang::abort(message = "Missing required parameter `query`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `query`."))
      }

      if (nchar(`query`) > 4096) {
        rlang::abort(message = "Invalid length for `query` when calling TweetsApi$tweet_counts_full_archive_search, must be smaller than or equal to 4096.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for $query when calling TweetsApi.tweet_counts_full_archive_search, must be smaller than or equal to 4096."))
      }
      if (nchar(`query`) < 1) {
        rlang::abort(message = "Invalid length for `query` when calling TweetsApi$tweet_counts_full_archive_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `query` when calling TweetsApi$tweet_counts_full_archive_search, must be bigger than or equal to 1."))
      }



      if (!str_detect(`since_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `since_id` when calling TweetsApi$tweet_counts_full_archive_search, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `since_id` when calling TweetsApi$tweet_counts_full_archive_search, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (!str_detect(`until_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `until_id` when calling TweetsApi$tweet_counts_full_archive_search, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `until_id` when calling TweetsApi$tweet_counts_full_archive_search, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (nchar(`next_token`) < 1) {
        rlang::abort(message = "Invalid length for `next_token` when calling TweetsApi$tweet_counts_full_archive_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `next_token` when calling TweetsApi$tweet_counts_full_archive_search, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$tweet_counts_full_archive_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$tweet_counts_full_archive_search, must be bigger than or equal to 1."))
      }


      if (length(`search_count_fields`) < 1) {
        rlang::abort(message = "Invalid length for `search_count_fields` when calling TweetsApi$tweet_counts_full_archive_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `search_count_fields` when calling TweetsApi$tweet_counts_full_archive_search, number of items must be greater than or equal to 1."))
      }

      query_params[["query"]] <- `query`

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      query_params[["since_id"]] <- `since_id`

      query_params[["until_id"]] <- `until_id`

      query_params[["next_token"]] <- `next_token`

      query_params[["pagination_token"]] <- `pagination_token`

      if (!(`granularity` %in% c("minute", "hour", "day"))) {
        rlang::abort(message = "Invalid value for `granularity` when calling TweetsApi$tweet_counts_full_archive_search. Must be [minute, hour, day].",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `granularity` when calling TweetsApi$tweet_counts_full_archive_search. Must be [minute, hour, day]."))
      }
      query_params[["granularity"]] <- `granularity`

      # check if items are unique
      if (!identical(`search_count_fields`, unique(`search_count_fields`))) {
        rlang::abort(message = "Invalid value for `search_count_fields` when calling TweetsApi$tweet_counts_full_archive_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `search_count_fields` when calling TweetsApi$tweet_counts_full_archive_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `search_count_fields`) {
        if (!(query_item %in% c("end", "start", "tweet_count"))) {
          rlang::abort(message = "Invalid value for `search_count_fields` when calling TweetsApi$tweet_counts_full_archive_search. Must be [end, start, tweet_count].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `search_count_fields` when calling TweetsApi$tweet_counts_full_archive_search. Must be [end, start, tweet_count]."))
        }
      }
      query_params[["search_count.fields"]] <- I(paste(lapply(`search_count_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/counts/all"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2TweetsCountsAllResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Recent search counts
    #'
    #' @description
    #' Recent search counts
    #'
    #' @param query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    #' @param since_id (optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    #' @param until_id (optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.
    #' @param next_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param granularity (optional) The granularity for the search counts results. (default value: "hour")
    #' @param search_count_fields (optional) A comma separated list of SearchCount fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2TweetsCountsRecentResponse
    #' @export
    tweet_counts_recent_search = function(query, start_time = NULL, end_time = NULL, since_id = NULL, until_id = NULL, next_token = NULL, pagination_token = NULL, granularity = "hour", search_count_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$tweet_counts_recent_search_with_http_info(query, start_time, end_time, since_id, until_id, next_token, pagination_token, granularity, search_count_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Recent search counts
    #'
    #' @description
    #' Recent search counts
    #'
    #' @param query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    #' @param since_id (optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    #' @param until_id (optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.
    #' @param next_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param granularity (optional) The granularity for the search counts results. (default value: "hour")
    #' @param search_count_fields (optional) A comma separated list of SearchCount fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2TweetsCountsRecentResponse) with additional information such as HTTP status code, headers
    #' @export
    tweet_counts_recent_search_with_http_info = function(query, start_time = NULL, end_time = NULL, since_id = NULL, until_id = NULL, next_token = NULL, pagination_token = NULL, granularity = "hour", search_count_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`query`)) {
        rlang::abort(message = "Missing required parameter `query`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `query`."))
      }

      if (nchar(`query`) > 4096) {
        rlang::abort(message = "Invalid length for `query` when calling TweetsApi$tweet_counts_recent_search, must be smaller than or equal to 4096.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for $query when calling TweetsApi.tweet_counts_recent_search, must be smaller than or equal to 4096."))
      }
      if (nchar(`query`) < 1) {
        rlang::abort(message = "Invalid length for `query` when calling TweetsApi$tweet_counts_recent_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `query` when calling TweetsApi$tweet_counts_recent_search, must be bigger than or equal to 1."))
      }



      if (!str_detect(`since_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `since_id` when calling TweetsApi$tweet_counts_recent_search, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `since_id` when calling TweetsApi$tweet_counts_recent_search, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (!str_detect(`until_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `until_id` when calling TweetsApi$tweet_counts_recent_search, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `until_id` when calling TweetsApi$tweet_counts_recent_search, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (nchar(`next_token`) < 1) {
        rlang::abort(message = "Invalid length for `next_token` when calling TweetsApi$tweet_counts_recent_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `next_token` when calling TweetsApi$tweet_counts_recent_search, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$tweet_counts_recent_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$tweet_counts_recent_search, must be bigger than or equal to 1."))
      }


      if (length(`search_count_fields`) < 1) {
        rlang::abort(message = "Invalid length for `search_count_fields` when calling TweetsApi$tweet_counts_recent_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `search_count_fields` when calling TweetsApi$tweet_counts_recent_search, number of items must be greater than or equal to 1."))
      }

      query_params[["query"]] <- `query`

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      query_params[["since_id"]] <- `since_id`

      query_params[["until_id"]] <- `until_id`

      query_params[["next_token"]] <- `next_token`

      query_params[["pagination_token"]] <- `pagination_token`

      if (!(`granularity` %in% c("minute", "hour", "day"))) {
        rlang::abort(message = "Invalid value for `granularity` when calling TweetsApi$tweet_counts_recent_search. Must be [minute, hour, day].",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `granularity` when calling TweetsApi$tweet_counts_recent_search. Must be [minute, hour, day]."))
      }
      query_params[["granularity"]] <- `granularity`

      # check if items are unique
      if (!identical(`search_count_fields`, unique(`search_count_fields`))) {
        rlang::abort(message = "Invalid value for `search_count_fields` when calling TweetsApi$tweet_counts_recent_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `search_count_fields` when calling TweetsApi$tweet_counts_recent_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `search_count_fields`) {
        if (!(query_item %in% c("end", "start", "tweet_count"))) {
          rlang::abort(message = "Invalid value for `search_count_fields` when calling TweetsApi$tweet_counts_recent_search. Must be [end, start, tweet_count].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `search_count_fields` when calling TweetsApi$tweet_counts_recent_search. Must be [end, start, tweet_count]."))
        }
      }
      query_params[["search_count.fields"]] <- I(paste(lapply(`search_count_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/counts/recent"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2TweetsCountsRecentResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Full-archive search
    #'
    #' @description
    #' Full-archive search
    #'
    #' @param query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    #' @param since_id (optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    #' @param until_id (optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.
    #' @param max_results (optional) The maximum number of search results to be returned by a request. (default value: 10)
    #' @param next_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param sort_order (optional) This order in which to return results.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2TweetsSearchAllResponse
    #' @export
    tweets_fullarchive_search = function(query, start_time = NULL, end_time = NULL, since_id = NULL, until_id = NULL, max_results = 10, next_token = NULL, pagination_token = NULL, sort_order = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$tweets_fullarchive_search_with_http_info(query, start_time, end_time, since_id, until_id, max_results, next_token, pagination_token, sort_order, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Full-archive search
    #'
    #' @description
    #' Full-archive search
    #'
    #' @param query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    #' @param since_id (optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    #' @param until_id (optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.
    #' @param max_results (optional) The maximum number of search results to be returned by a request. (default value: 10)
    #' @param next_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param sort_order (optional) This order in which to return results.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2TweetsSearchAllResponse) with additional information such as HTTP status code, headers
    #' @export
    tweets_fullarchive_search_with_http_info = function(query, start_time = NULL, end_time = NULL, since_id = NULL, until_id = NULL, max_results = 10, next_token = NULL, pagination_token = NULL, sort_order = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`query`)) {
        rlang::abort(message = "Missing required parameter `query`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `query`."))
      }

      if (nchar(`query`) > 4096) {
        rlang::abort(message = "Invalid length for `query` when calling TweetsApi$tweets_fullarchive_search, must be smaller than or equal to 4096.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for $query when calling TweetsApi.tweets_fullarchive_search, must be smaller than or equal to 4096."))
      }
      if (nchar(`query`) < 1) {
        rlang::abort(message = "Invalid length for `query` when calling TweetsApi$tweets_fullarchive_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `query` when calling TweetsApi$tweets_fullarchive_search, must be bigger than or equal to 1."))
      }



      if (!str_detect(`since_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `since_id` when calling TweetsApi$tweets_fullarchive_search, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `since_id` when calling TweetsApi$tweets_fullarchive_search, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (!str_detect(`until_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `until_id` when calling TweetsApi$tweets_fullarchive_search, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `until_id` when calling TweetsApi$tweets_fullarchive_search, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 500) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$tweets_fullarchive_search, must be smaller than or equal to 500.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$tweets_fullarchive_search, must be smaller than or equal to 500."))
      }
      if (`max_results` < 10) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$tweets_fullarchive_search, must be bigger than or equal to 10.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$tweets_fullarchive_search, must be bigger than or equal to 10."))
      }

      if (nchar(`next_token`) < 1) {
        rlang::abort(message = "Invalid length for `next_token` when calling TweetsApi$tweets_fullarchive_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `next_token` when calling TweetsApi$tweets_fullarchive_search, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$tweets_fullarchive_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$tweets_fullarchive_search, must be bigger than or equal to 1."))
      }


      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$tweets_fullarchive_search, number of items must be greater than or equal to 1."))
      }

      query_params[["query"]] <- `query`

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      query_params[["since_id"]] <- `since_id`

      query_params[["until_id"]] <- `until_id`

      query_params[["max_results"]] <- `max_results`

      query_params[["next_token"]] <- `next_token`

      query_params[["pagination_token"]] <- `pagination_token`

      if (!(`sort_order` %in% c("recency", "relevancy"))) {
        rlang::abort(message = "Invalid value for `sort_order` when calling TweetsApi$tweets_fullarchive_search. Must be [recency, relevancy].",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `sort_order` when calling TweetsApi$tweets_fullarchive_search. Must be [recency, relevancy]."))
      }
      query_params[["sort_order"]] <- `sort_order`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$tweets_fullarchive_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$tweets_fullarchive_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$tweets_fullarchive_search. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$tweets_fullarchive_search. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$tweets_fullarchive_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$tweets_fullarchive_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$tweets_fullarchive_search. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$tweets_fullarchive_search. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$tweets_fullarchive_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$tweets_fullarchive_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$tweets_fullarchive_search. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$tweets_fullarchive_search. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$tweets_fullarchive_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$tweets_fullarchive_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$tweets_fullarchive_search. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$tweets_fullarchive_search. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$tweets_fullarchive_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$tweets_fullarchive_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$tweets_fullarchive_search. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$tweets_fullarchive_search. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$tweets_fullarchive_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$tweets_fullarchive_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$tweets_fullarchive_search. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$tweets_fullarchive_search. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/search/all"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2TweetsSearchAllResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Recent search
    #'
    #' @description
    #' Recent search
    #'
    #' @param query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    #' @param since_id (optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    #' @param until_id (optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.
    #' @param max_results (optional) The maximum number of search results to be returned by a request. (default value: 10)
    #' @param next_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param sort_order (optional) This order in which to return results.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2TweetsSearchRecentResponse
    #' @export
    tweets_recent_search = function(query, start_time = NULL, end_time = NULL, since_id = NULL, until_id = NULL, max_results = 10, next_token = NULL, pagination_token = NULL, sort_order = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$tweets_recent_search_with_http_info(query, start_time, end_time, since_id, until_id, max_results, next_token, pagination_token, sort_order, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Recent search
    #'
    #' @description
    #' Recent search
    #'
    #' @param query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
    #' @param since_id (optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
    #' @param until_id (optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.
    #' @param max_results (optional) The maximum number of search results to be returned by a request. (default value: 10)
    #' @param next_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
    #' @param sort_order (optional) This order in which to return results.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2TweetsSearchRecentResponse) with additional information such as HTTP status code, headers
    #' @export
    tweets_recent_search_with_http_info = function(query, start_time = NULL, end_time = NULL, since_id = NULL, until_id = NULL, max_results = 10, next_token = NULL, pagination_token = NULL, sort_order = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`query`)) {
        rlang::abort(message = "Missing required parameter `query`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `query`."))
      }

      if (nchar(`query`) > 4096) {
        rlang::abort(message = "Invalid length for `query` when calling TweetsApi$tweets_recent_search, must be smaller than or equal to 4096.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for $query when calling TweetsApi.tweets_recent_search, must be smaller than or equal to 4096."))
      }
      if (nchar(`query`) < 1) {
        rlang::abort(message = "Invalid length for `query` when calling TweetsApi$tweets_recent_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `query` when calling TweetsApi$tweets_recent_search, must be bigger than or equal to 1."))
      }



      if (!str_detect(`since_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `since_id` when calling TweetsApi$tweets_recent_search, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `since_id` when calling TweetsApi$tweets_recent_search, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (!str_detect(`until_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `until_id` when calling TweetsApi$tweets_recent_search, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `until_id` when calling TweetsApi$tweets_recent_search, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$tweets_recent_search, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$tweets_recent_search, must be smaller than or equal to 100."))
      }
      if (`max_results` < 10) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$tweets_recent_search, must be bigger than or equal to 10.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$tweets_recent_search, must be bigger than or equal to 10."))
      }

      if (nchar(`next_token`) < 1) {
        rlang::abort(message = "Invalid length for `next_token` when calling TweetsApi$tweets_recent_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `next_token` when calling TweetsApi$tweets_recent_search, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$tweets_recent_search, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$tweets_recent_search, must be bigger than or equal to 1."))
      }


      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$tweets_recent_search, number of items must be greater than or equal to 1."))
      }

      query_params[["query"]] <- `query`

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      query_params[["since_id"]] <- `since_id`

      query_params[["until_id"]] <- `until_id`

      query_params[["max_results"]] <- `max_results`

      query_params[["next_token"]] <- `next_token`

      query_params[["pagination_token"]] <- `pagination_token`

      if (!(`sort_order` %in% c("recency", "relevancy"))) {
        rlang::abort(message = "Invalid value for `sort_order` when calling TweetsApi$tweets_recent_search. Must be [recency, relevancy].",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `sort_order` when calling TweetsApi$tweets_recent_search. Must be [recency, relevancy]."))
      }
      query_params[["sort_order"]] <- `sort_order`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$tweets_recent_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$tweets_recent_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$tweets_recent_search. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$tweets_recent_search. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$tweets_recent_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$tweets_recent_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$tweets_recent_search. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$tweets_recent_search. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$tweets_recent_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$tweets_recent_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$tweets_recent_search. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$tweets_recent_search. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$tweets_recent_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$tweets_recent_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$tweets_recent_search. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$tweets_recent_search. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$tweets_recent_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$tweets_recent_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$tweets_recent_search. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$tweets_recent_search. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$tweets_recent_search. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$tweets_recent_search. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$tweets_recent_search. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$tweets_recent_search. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/tweets/search/recent"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2TweetsSearchRecentResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Causes the User (in the path) to like the specified Tweet
    #'
    #' @description
    #' Causes the User (in the path) to like the specified Tweet
    #'
    #' @param id The ID of the authenticated source User that is requesting to like the Tweet.
    #' @param users_likes_create_request (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return UsersLikesCreateResponse
    #' @export
    users_id_like = function(id, users_likes_create_request = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_like_with_http_info(id, users_likes_create_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Causes the User (in the path) to like the specified Tweet
    #'
    #' @description
    #' Causes the User (in the path) to like the specified Tweet
    #'
    #' @param id The ID of the authenticated source User that is requesting to like the Tweet.
    #' @param users_likes_create_request (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (UsersLikesCreateResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_like_with_http_info = function(id, users_likes_create_request = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }



      if (!is.null(`users_likes_create_request`)) {
        local_var_body <- `users_likes_create_request`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/2/users/{id}/likes"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read like.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "UsersLikesCreateResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Returns Tweet objects liked by the provided User ID
    #'
    #' @description
    #' Returns Tweet objects liked by the provided User ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersIdLikedTweetsResponse
    #' @export
    users_id_liked_tweets = function(id, max_results = NULL, pagination_token = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_liked_tweets_with_http_info(id, max_results, pagination_token, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Returns Tweet objects liked by the provided User ID
    #'
    #' @description
    #' Returns Tweet objects liked by the provided User ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersIdLikedTweetsResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_liked_tweets_with_http_info = function(id, max_results = NULL, pagination_token = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling TweetsApi$users_id_liked_tweets, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling TweetsApi$users_id_liked_tweets, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$users_id_liked_tweets, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$users_id_liked_tweets, must be smaller than or equal to 100."))
      }
      if (`max_results` < 5) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$users_id_liked_tweets, must be bigger than or equal to 5.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$users_id_liked_tweets, must be bigger than or equal to 5."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$users_id_liked_tweets, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$users_id_liked_tweets, must be bigger than or equal to 1."))
      }

      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$users_id_liked_tweets, number of items must be greater than or equal to 1."))
      }

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_liked_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_liked_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_liked_tweets. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_liked_tweets. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$users_id_liked_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$users_id_liked_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$users_id_liked_tweets. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$users_id_liked_tweets. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$users_id_liked_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$users_id_liked_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$users_id_liked_tweets. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$users_id_liked_tweets. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$users_id_liked_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$users_id_liked_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$users_id_liked_tweets. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$users_id_liked_tweets. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$users_id_liked_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$users_id_liked_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$users_id_liked_tweets. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$users_id_liked_tweets. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$users_id_liked_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$users_id_liked_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$users_id_liked_tweets. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$users_id_liked_tweets. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/{id}/liked_tweets"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read like.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersIdLikedTweetsResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' User mention timeline by User ID
    #'
    #' @description
    #' User mention timeline by User ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param since_id (optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
    #' @param until_id (optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersIdMentionsResponse
    #' @export
    users_id_mentions = function(id, since_id = NULL, until_id = NULL, max_results = NULL, pagination_token = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_mentions_with_http_info(id, since_id, until_id, max_results, pagination_token, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' User mention timeline by User ID
    #'
    #' @description
    #' User mention timeline by User ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param since_id (optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
    #' @param until_id (optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersIdMentionsResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_mentions_with_http_info = function(id, since_id = NULL, until_id = NULL, max_results = NULL, pagination_token = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling TweetsApi$users_id_mentions, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling TweetsApi$users_id_mentions, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (!str_detect(`since_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `since_id` when calling TweetsApi$users_id_mentions, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `since_id` when calling TweetsApi$users_id_mentions, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (!str_detect(`until_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `until_id` when calling TweetsApi$users_id_mentions, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `until_id` when calling TweetsApi$users_id_mentions, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$users_id_mentions, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$users_id_mentions, must be smaller than or equal to 100."))
      }
      if (`max_results` < 5) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$users_id_mentions, must be bigger than or equal to 5.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$users_id_mentions, must be bigger than or equal to 5."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$users_id_mentions, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$users_id_mentions, must be bigger than or equal to 1."))
      }



      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$users_id_mentions, number of items must be greater than or equal to 1."))
      }

      query_params[["since_id"]] <- `since_id`

      query_params[["until_id"]] <- `until_id`

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_mentions. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_mentions. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_mentions. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_mentions. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$users_id_mentions. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$users_id_mentions. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$users_id_mentions. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$users_id_mentions. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$users_id_mentions. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$users_id_mentions. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$users_id_mentions. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$users_id_mentions. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$users_id_mentions. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$users_id_mentions. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$users_id_mentions. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$users_id_mentions. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$users_id_mentions. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$users_id_mentions. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$users_id_mentions. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$users_id_mentions. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$users_id_mentions. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$users_id_mentions. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$users_id_mentions. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$users_id_mentions. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/{id}/mentions"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersIdMentionsResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Causes the User (in the path) to retweet the specified Tweet.
    #'
    #' @description
    #' Causes the User (in the path) to retweet the specified Tweet.
    #'
    #' @param id The ID of the authenticated source User that is requesting to retweet the Tweet.
    #' @param users_retweets_create_request (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return UsersRetweetsCreateResponse
    #' @export
    users_id_retweets = function(id, users_retweets_create_request = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_retweets_with_http_info(id, users_retweets_create_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Causes the User (in the path) to retweet the specified Tweet.
    #'
    #' @description
    #' Causes the User (in the path) to retweet the specified Tweet.
    #'
    #' @param id The ID of the authenticated source User that is requesting to retweet the Tweet.
    #' @param users_retweets_create_request (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (UsersRetweetsCreateResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_retweets_with_http_info = function(id, users_retweets_create_request = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }



      if (!is.null(`users_retweets_create_request`)) {
        local_var_body <- `users_retweets_create_request`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/2/users/{id}/retweets"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read tweet.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "UsersRetweetsCreateResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' User home timeline by User ID
    #'
    #' @description
    #' User home timeline by User ID
    #'
    #' @param id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.
    #' @param since_id (optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
    #' @param until_id (optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param exclude (optional) The set of entities to exclude (e.g. 'replies' or 'retweets').
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersIdTimelinesReverseChronologicalResponse
    #' @export
    users_id_timeline = function(id, since_id = NULL, until_id = NULL, max_results = NULL, pagination_token = NULL, exclude = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_timeline_with_http_info(id, since_id, until_id, max_results, pagination_token, exclude, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' User home timeline by User ID
    #'
    #' @description
    #' User home timeline by User ID
    #'
    #' @param id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.
    #' @param since_id (optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
    #' @param until_id (optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param exclude (optional) The set of entities to exclude (e.g. 'replies' or 'retweets').
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersIdTimelinesReverseChronologicalResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_timeline_with_http_info = function(id, since_id = NULL, until_id = NULL, max_results = NULL, pagination_token = NULL, exclude = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }


      if (!str_detect(`since_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `since_id` when calling TweetsApi$users_id_timeline, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `since_id` when calling TweetsApi$users_id_timeline, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (!str_detect(`until_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `until_id` when calling TweetsApi$users_id_timeline, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `until_id` when calling TweetsApi$users_id_timeline, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$users_id_timeline, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$users_id_timeline, must be smaller than or equal to 100."))
      }
      if (`max_results` < 1) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$users_id_timeline, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$users_id_timeline, must be bigger than or equal to 1."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$users_id_timeline, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$users_id_timeline, must be bigger than or equal to 1."))
      }




      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$users_id_timeline, number of items must be greater than or equal to 1."))
      }

      query_params[["since_id"]] <- `since_id`

      query_params[["until_id"]] <- `until_id`

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`exclude`, unique(`exclude`))) {
        rlang::abort(message = "Invalid value for `exclude` when calling TweetsApi$users_id_timeline. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `exclude` when calling TweetsApi$users_id_timeline. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `exclude`) {
        if (!(query_item %in% c("replies", "retweets"))) {
          rlang::abort(message = "Invalid value for `exclude` when calling TweetsApi$users_id_timeline. Must be [replies, retweets].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `exclude` when calling TweetsApi$users_id_timeline. Must be [replies, retweets]."))
        }
      }
      query_params[["exclude"]] <- I(paste(lapply(`exclude`, URLencode, reserved = TRUE), collapse = ","))

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_timeline. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_timeline. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_timeline. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_timeline. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$users_id_timeline. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$users_id_timeline. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$users_id_timeline. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$users_id_timeline. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$users_id_timeline. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$users_id_timeline. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$users_id_timeline. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$users_id_timeline. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$users_id_timeline. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$users_id_timeline. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$users_id_timeline. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$users_id_timeline. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$users_id_timeline. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$users_id_timeline. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$users_id_timeline. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$users_id_timeline. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$users_id_timeline. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$users_id_timeline. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$users_id_timeline. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$users_id_timeline. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/{id}/timelines/reverse_chronological"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersIdTimelinesReverseChronologicalResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' User Tweets timeline by User ID
    #'
    #' @description
    #' User Tweets timeline by User ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param since_id (optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
    #' @param until_id (optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param exclude (optional) The set of entities to exclude (e.g. 'replies' or 'retweets').
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return Get2UsersIdTweetsResponse
    #' @export
    users_id_tweets = function(id, since_id = NULL, until_id = NULL, max_results = NULL, pagination_token = NULL, exclude = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      local_var_response <- self$users_id_tweets_with_http_info(id, since_id, until_id, max_results, pagination_token, exclude, start_time, end_time, tweet_fields, expansions, media_fields, poll_fields, user_fields, place_fields, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' User Tweets timeline by User ID
    #'
    #' @description
    #' User Tweets timeline by User ID
    #'
    #' @param id The ID of the User to lookup.
    #' @param since_id (optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
    #' @param until_id (optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
    #' @param max_results (optional) The maximum number of results.
    #' @param pagination_token (optional) This parameter is used to get the next 'page' of results.
    #' @param exclude (optional) The set of entities to exclude (e.g. 'replies' or 'retweets').
    #' @param start_time (optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
    #' @param end_time (optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
    #' @param tweet_fields (optional) A comma separated list of Tweet fields to display.
    #' @param expansions (optional) A comma separated list of fields to expand.
    #' @param media_fields (optional) A comma separated list of Media fields to display.
    #' @param poll_fields (optional) A comma separated list of Poll fields to display.
    #' @param user_fields (optional) A comma separated list of User fields to display.
    #' @param place_fields (optional) A comma separated list of Place fields to display.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (Get2UsersIdTweetsResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_tweets_with_http_info = function(id, since_id = NULL, until_id = NULL, max_results = NULL, pagination_token = NULL, exclude = NULL, start_time = NULL, end_time = NULL, tweet_fields = NULL, expansions = NULL, media_fields = NULL, poll_fields = NULL, user_fields = NULL, place_fields = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (!str_detect(`id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `id` when calling TweetsApi$users_id_tweets, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `id` when calling TweetsApi$users_id_tweets, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (!str_detect(`since_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `since_id` when calling TweetsApi$users_id_tweets, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `since_id` when calling TweetsApi$users_id_tweets, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (!str_detect(`until_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `until_id` when calling TweetsApi$users_id_tweets, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `until_id` when calling TweetsApi$users_id_tweets, must conform to the pattern ^[0-9]{1,19}$."))
      }

      if (`max_results` > 100) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$users_id_tweets, must be smaller than or equal to 100.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$users_id_tweets, must be smaller than or equal to 100."))
      }
      if (`max_results` < 5) {
        rlang::abort(message = "Invalid value for `max_results` when calling TweetsApi$users_id_tweets, must be bigger than or equal to 5.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `max_results` when calling TweetsApi$users_id_tweets, must be bigger than or equal to 5."))
      }

      if (nchar(`pagination_token`) < 1) {
        rlang::abort(message = "Invalid length for `pagination_token` when calling TweetsApi$users_id_tweets, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `pagination_token` when calling TweetsApi$users_id_tweets, must be bigger than or equal to 1."))
      }

      if (length(`exclude`) < 1) {
        rlang::abort(message = "Invalid length for `exclude` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `exclude` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1."))
      }



      if (length(`tweet_fields`) < 1) {
        rlang::abort(message = "Invalid length for `tweet_fields` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `tweet_fields` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`expansions`) < 1) {
        rlang::abort(message = "Invalid length for `expansions` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `expansions` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`media_fields`) < 1) {
        rlang::abort(message = "Invalid length for `media_fields` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `media_fields` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`poll_fields`) < 1) {
        rlang::abort(message = "Invalid length for `poll_fields` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `poll_fields` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`user_fields`) < 1) {
        rlang::abort(message = "Invalid length for `user_fields` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `user_fields` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1."))
      }

      if (length(`place_fields`) < 1) {
        rlang::abort(message = "Invalid length for `place_fields` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid length for `place_fields` when calling TweetsApi$users_id_tweets, number of items must be greater than or equal to 1."))
      }

      query_params[["since_id"]] <- `since_id`

      query_params[["until_id"]] <- `until_id`

      query_params[["max_results"]] <- `max_results`

      query_params[["pagination_token"]] <- `pagination_token`

      # check if items are unique
      if (!identical(`exclude`, unique(`exclude`))) {
        rlang::abort(message = "Invalid value for `exclude` when calling TweetsApi$users_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `exclude` when calling TweetsApi$users_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `exclude`) {
        if (!(query_item %in% c("replies", "retweets"))) {
          rlang::abort(message = "Invalid value for `exclude` when calling TweetsApi$users_id_tweets. Must be [replies, retweets].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `exclude` when calling TweetsApi$users_id_tweets. Must be [replies, retweets]."))
        }
      }
      query_params[["exclude"]] <- I(paste(lapply(`exclude`, URLencode, reserved = TRUE), collapse = ","))

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      # check if items are unique
      if (!identical(`tweet_fields`, unique(`tweet_fields`))) {
        rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `tweet_fields`) {
        if (!(query_item %in% c("attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"))) {
          rlang::abort(message = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_tweets. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `tweet_fields` when calling TweetsApi$users_id_tweets. Must be [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld]."))
        }
      }
      query_params[["tweet.fields"]] <- I(paste(lapply(`tweet_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`expansions`, unique(`expansions`))) {
        rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$users_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `expansions` when calling TweetsApi$users_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `expansions`) {
        if (!(query_item %in% c("attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"))) {
          rlang::abort(message = "Invalid value for `expansions` when calling TweetsApi$users_id_tweets. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `expansions` when calling TweetsApi$users_id_tweets. Must be [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id]."))
        }
      }
      query_params[["expansions"]] <- I(paste(lapply(`expansions`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`media_fields`, unique(`media_fields`))) {
        rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$users_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `media_fields` when calling TweetsApi$users_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `media_fields`) {
        if (!(query_item %in% c("alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"))) {
          rlang::abort(message = "Invalid value for `media_fields` when calling TweetsApi$users_id_tweets. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `media_fields` when calling TweetsApi$users_id_tweets. Must be [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width]."))
        }
      }
      query_params[["media.fields"]] <- I(paste(lapply(`media_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`poll_fields`, unique(`poll_fields`))) {
        rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$users_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `poll_fields` when calling TweetsApi$users_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `poll_fields`) {
        if (!(query_item %in% c("duration_minutes", "end_datetime", "id", "options", "voting_status"))) {
          rlang::abort(message = "Invalid value for `poll_fields` when calling TweetsApi$users_id_tweets. Must be [duration_minutes, end_datetime, id, options, voting_status].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `poll_fields` when calling TweetsApi$users_id_tweets. Must be [duration_minutes, end_datetime, id, options, voting_status]."))
        }
      }
      query_params[["poll.fields"]] <- I(paste(lapply(`poll_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`user_fields`, unique(`user_fields`))) {
        rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$users_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `user_fields` when calling TweetsApi$users_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `user_fields`) {
        if (!(query_item %in% c("created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"))) {
          rlang::abort(message = "Invalid value for `user_fields` when calling TweetsApi$users_id_tweets. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `user_fields` when calling TweetsApi$users_id_tweets. Must be [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld]."))
        }
      }
      query_params[["user.fields"]] <- I(paste(lapply(`user_fields`, URLencode, reserved = TRUE), collapse = ","))

      # check if items are unique
      if (!identical(`place_fields`, unique(`place_fields`))) {
        rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$users_id_tweets. Items must be unique.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `place_fields` when calling TweetsApi$users_id_tweets. Items must be unique."))
      }
      # no explore
      # validate enum values
      for (query_item in `place_fields`) {
        if (!(query_item %in% c("contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"))) {
          rlang::abort(message = "Invalid value for `place_fields` when calling TweetsApi$users_id_tweets. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type].",
                       .subclass = "ApiException",
                       ApiException = ApiException$new(status = 0,
                                                       reason = "Invalid value for `place_fields` when calling TweetsApi$users_id_tweets. Must be [contained_within, country, country_code, full_name, geo, id, name, place_type]."))
        }
      }
      query_params[["place.fields"]] <- I(paste(lapply(`place_fields`, URLencode, reserved = TRUE), collapse = ","))

      local_var_url_path <- "/2/users/{id}/tweets"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "tweet.read users.read"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "Get2UsersIdTweetsResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Causes the User (in the path) to unlike the specified Tweet
    #'
    #' @description
    #' Causes the User (in the path) to unlike the specified Tweet
    #'
    #' @param id The ID of the authenticated source User that is requesting to unlike the Tweet.
    #' @param tweet_id The ID of the Tweet that the User is requesting to unlike.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return UsersLikesDeleteResponse
    #' @export
    users_id_unlike = function(id, tweet_id, data_file = NULL, ...) {
      local_var_response <- self$users_id_unlike_with_http_info(id, tweet_id, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Causes the User (in the path) to unlike the specified Tweet
    #'
    #' @description
    #' Causes the User (in the path) to unlike the specified Tweet
    #'
    #' @param id The ID of the authenticated source User that is requesting to unlike the Tweet.
    #' @param tweet_id The ID of the Tweet that the User is requesting to unlike.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (UsersLikesDeleteResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_unlike_with_http_info = function(id, tweet_id, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (missing(`tweet_id`)) {
        rlang::abort(message = "Missing required parameter `tweet_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `tweet_id`."))
      }


      if (!str_detect(`tweet_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `tweet_id` when calling TweetsApi$users_id_unlike, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `tweet_id` when calling TweetsApi$users_id_unlike, must conform to the pattern ^[0-9]{1,19}$."))
      }

      local_var_url_path <- "/2/users/{id}/likes/{tweet_id}"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`tweet_id`)) {
        local_var_url_path <- gsub("\\{tweet_id\\}", URLencode(as.character(`tweet_id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read like.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "DELETE",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "UsersLikesDeleteResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    },
    #' Causes the User (in the path) to unretweet the specified Tweet
    #'
    #' @description
    #' Causes the User (in the path) to unretweet the specified Tweet
    #'
    #' @param id The ID of the authenticated source User that is requesting to retweet the Tweet.
    #' @param source_tweet_id The ID of the Tweet that the User is requesting to unretweet.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return UsersRetweetsDeleteResponse
    #' @export
    users_id_unretweets = function(id, source_tweet_id, data_file = NULL, ...) {
      local_var_response <- self$users_id_unretweets_with_http_info(id, source_tweet_id, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Causes the User (in the path) to unretweet the specified Tweet
    #'
    #' @description
    #' Causes the User (in the path) to unretweet the specified Tweet
    #'
    #' @param id The ID of the authenticated source User that is requesting to retweet the Tweet.
    #' @param source_tweet_id The ID of the Tweet that the User is requesting to unretweet.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (UsersRetweetsDeleteResponse) with additional information such as HTTP status code, headers
    #' @export
    users_id_unretweets_with_http_info = function(id, source_tweet_id, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`id`)) {
        rlang::abort(message = "Missing required parameter `id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `id`."))
      }

      if (missing(`source_tweet_id`)) {
        rlang::abort(message = "Missing required parameter `source_tweet_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `source_tweet_id`."))
      }


      if (!str_detect(`source_tweet_id`, "^[0-9]{1,19}$")) {
        rlang::abort(message = "Invalid value for `source_tweet_id` when calling TweetsApi$users_id_unretweets, must conform to the pattern ^[0-9]{1,19}$.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `source_tweet_id` when calling TweetsApi$users_id_unretweets, must conform to the pattern ^[0-9]{1,19}$."))
      }

      local_var_url_path <- "/2/users/{id}/retweets/{source_tweet_id}"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`source_tweet_id`)) {
        local_var_url_path <- gsub("\\{source_tweet_id\\}", URLencode(as.character(`source_tweet_id`), reserved = TRUE), local_var_url_path)
      }

      # OAuth-related settings
      is_oauth <- TRUE
      oauth_scopes <- "users.read tweet.read tweet.write"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "DELETE",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "UsersRetweetsDeleteResponse", loadNamespace("twitter")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- paste("Server returned ", local_var_resp$status_code, " response status code.")
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api client exception encountered."
        }
        rlang::abort(message = local_var_error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        local_var_error_msg <- local_var_resp$response
        if (local_var_error_msg == "") {
          local_var_error_msg <- "Api server exception encountered."
        }
        rlang::abort(message = error_msg,
                     .subclass = "ApiException",
                     ApiException = ApiException$new(http_response = local_var_resp))
      }
    }
  )
)
