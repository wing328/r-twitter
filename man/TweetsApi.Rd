% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tweets_api.R
\docType{class}
\name{TweetsApi}
\alias{TweetsApi}
\title{Tweets operations}
\format{
An \code{R6Class} generator object
}
\description{
twitter.Tweets
}
\details{
Twitter API v2

Twitter API v2 available endpoints

The version of the OpenAPI document: 2.49
Generated by: https://openapi-generator.tech
}
\section{Methods}{

\describe{
\strong{ add_or_delete_rules } \emph{ Add/Delete rules }
Add or delete rules from a User's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.

\itemize{
\item \emph{ @param } add_or_delete_rules_request \link{AddOrDeleteRulesRequest}
\item \emph{ @param } dry_run character
\item \emph{ @returnType } \link{AddOrDeleteRulesResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : AddOrDeleteRulesResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ create_tweet } \emph{ Creation of a Tweet }
Causes the User to create a Tweet under the authorized account.

\itemize{
\item \emph{ @param } tweet_create_request \link{TweetCreateRequest}
\item \emph{ @returnType } \link{TweetCreateResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 201 | The request has succeeded.

\item return type : TweetCreateResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ delete_tweet_by_id } \emph{ Tweet delete by Tweet ID }
Delete specified Tweet (in the path) by ID.

\itemize{
\item \emph{ @param } id character
\item \emph{ @returnType } \link{TweetDeleteResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : TweetDeleteResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ find_tweet_by_id } \emph{ Tweet lookup by Tweet ID }
Returns a variety of information about the Tweet specified by the requested ID.

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2TweetsIdResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2TweetsIdResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ find_tweets_by_id } \emph{ Tweet lookup by Tweet IDs }
Returns a variety of information about the Tweet specified by the requested ID.

\itemize{
\item \emph{ @param } ids list( character )
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2TweetsResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2TweetsResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ find_tweets_that_quote_a_tweet } \emph{ Retrieve Tweets that quote a Tweet. }
Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } max_results integer
\item \emph{ @param } pagination_token character
\item \emph{ @param } exclude Enum < [replies, retweets] >
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2TweetsIdQuoteTweetsResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2TweetsIdQuoteTweetsResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ get_rules } \emph{ Rules lookup }
Returns rules from a User's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.

\itemize{
\item \emph{ @param } ids list( character )
\item \emph{ @param } max_results integer
\item \emph{ @param } pagination_token character
\item \emph{ @returnType } \link{RulesLookupResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : RulesLookupResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ get_tweets_firehose_stream } \emph{ Firehose stream }
Streams 100\% of public Tweets.

\itemize{
\item \emph{ @param } partition integer
\item \emph{ @param } backfill_minutes integer
\item \emph{ @param } start_time character
\item \emph{ @param } end_time character
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{StreamingTweetResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : StreamingTweetResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ get_tweets_sample10_stream } \emph{ Sample 10\% stream }
Streams a deterministic 10\% of public Tweets.

\itemize{
\item \emph{ @param } partition integer
\item \emph{ @param } backfill_minutes integer
\item \emph{ @param } start_time character
\item \emph{ @param } end_time character
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2TweetsSample10StreamResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2TweetsSample10StreamResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ hide_reply_by_id } \emph{ Hide replies }
Hides or unhides a reply to an owned conversation.

\itemize{
\item \emph{ @param } tweet_id character
\item \emph{ @param } tweet_hide_request \link{TweetHideRequest}
\item \emph{ @returnType } \link{TweetHideResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : TweetHideResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ lists_id_tweets } \emph{ List Tweets timeline by List ID. }
Returns a list of Tweets associated with the provided List ID.

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } max_results integer
\item \emph{ @param } pagination_token character
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2ListsIdTweetsResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2ListsIdTweetsResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ sample_stream } \emph{ Sample stream }
Streams a deterministic 1\% of public Tweets.

\itemize{
\item \emph{ @param } backfill_minutes integer
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{StreamingTweetResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : StreamingTweetResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ search_stream } \emph{ Filtered stream }
Streams Tweets matching the stream's active rule set.

\itemize{
\item \emph{ @param } backfill_minutes integer
\item \emph{ @param } start_time character
\item \emph{ @param } end_time character
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{FilteredStreamingTweetResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : FilteredStreamingTweetResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ space_buyers } \emph{ Retrieve the list of Users who purchased a ticket to the given space }
Retrieves the list of Users who purchased a ticket to the given space

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } pagination_token character
\item \emph{ @param } max_results integer
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } expansions Enum < [pinned_tweet_id] >
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @returnType } \link{Get2SpacesIdBuyersResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2SpacesIdBuyersResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ space_tweets } \emph{ Retrieve Tweets from a Space. }
Retrieves Tweets shared in the specified Space.

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } max_results integer
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2SpacesIdTweetsResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2SpacesIdTweetsResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ tweet_counts_full_archive_search } \emph{ Full archive search counts }
Returns Tweet Counts that match a search query.

\itemize{
\item \emph{ @param } query character
\item \emph{ @param } start_time character
\item \emph{ @param } end_time character
\item \emph{ @param } since_id character
\item \emph{ @param } until_id character
\item \emph{ @param } next_token character
\item \emph{ @param } pagination_token character
\item \emph{ @param } granularity Enum < [minute, hour, day] >
\item \emph{ @param } search_count_fields Enum < [end, start, tweet_count] >
\item \emph{ @returnType } \link{Get2TweetsCountsAllResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2TweetsCountsAllResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ tweet_counts_recent_search } \emph{ Recent search counts }
Returns Tweet Counts from the last 7 days that match a search query.

\itemize{
\item \emph{ @param } query character
\item \emph{ @param } start_time character
\item \emph{ @param } end_time character
\item \emph{ @param } since_id character
\item \emph{ @param } until_id character
\item \emph{ @param } next_token character
\item \emph{ @param } pagination_token character
\item \emph{ @param } granularity Enum < [minute, hour, day] >
\item \emph{ @param } search_count_fields Enum < [end, start, tweet_count] >
\item \emph{ @returnType } \link{Get2TweetsCountsRecentResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2TweetsCountsRecentResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ tweets_fullarchive_search } \emph{ Full-archive search }
Returns Tweets that match a search query.

\itemize{
\item \emph{ @param } query character
\item \emph{ @param } start_time character
\item \emph{ @param } end_time character
\item \emph{ @param } since_id character
\item \emph{ @param } until_id character
\item \emph{ @param } max_results integer
\item \emph{ @param } next_token character
\item \emph{ @param } pagination_token character
\item \emph{ @param } sort_order Enum < [recency, relevancy] >
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2TweetsSearchAllResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2TweetsSearchAllResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ tweets_recent_search } \emph{ Recent search }
Returns Tweets from the last 7 days that match a search query.

\itemize{
\item \emph{ @param } query character
\item \emph{ @param } start_time character
\item \emph{ @param } end_time character
\item \emph{ @param } since_id character
\item \emph{ @param } until_id character
\item \emph{ @param } max_results integer
\item \emph{ @param } next_token character
\item \emph{ @param } pagination_token character
\item \emph{ @param } sort_order Enum < [recency, relevancy] >
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2TweetsSearchRecentResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2TweetsSearchRecentResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ users_id_like } \emph{ Causes the User (in the path) to like the specified Tweet }
Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } users_likes_create_request \link{UsersLikesCreateRequest}
\item \emph{ @returnType } \link{UsersLikesCreateResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : UsersLikesCreateResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ users_id_liked_tweets } \emph{ Returns Tweet objects liked by the provided User ID }
Returns a list of Tweets liked by the provided User ID

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } max_results integer
\item \emph{ @param } pagination_token character
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2UsersIdLikedTweetsResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2UsersIdLikedTweetsResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ users_id_mentions } \emph{ User mention timeline by User ID }
Returns Tweet objects that mention username associated to the provided User ID

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } since_id character
\item \emph{ @param } until_id character
\item \emph{ @param } max_results integer
\item \emph{ @param } pagination_token character
\item \emph{ @param } start_time character
\item \emph{ @param } end_time character
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2UsersIdMentionsResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2UsersIdMentionsResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ users_id_retweets } \emph{ Causes the User (in the path) to retweet the specified Tweet. }
Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } users_retweets_create_request \link{UsersRetweetsCreateRequest}
\item \emph{ @returnType } \link{UsersRetweetsCreateResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : UsersRetweetsCreateResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ users_id_timeline } \emph{ User home timeline by User ID }
Returns Tweet objects that appears in the provided User ID's home timeline

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } since_id character
\item \emph{ @param } until_id character
\item \emph{ @param } max_results integer
\item \emph{ @param } pagination_token character
\item \emph{ @param } exclude Enum < [replies, retweets] >
\item \emph{ @param } start_time character
\item \emph{ @param } end_time character
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2UsersIdTimelinesReverseChronologicalResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2UsersIdTimelinesReverseChronologicalResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ users_id_tweets } \emph{ User Tweets timeline by User ID }
Returns a list of Tweets authored by the provided User ID

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } since_id character
\item \emph{ @param } until_id character
\item \emph{ @param } max_results integer
\item \emph{ @param } pagination_token character
\item \emph{ @param } exclude Enum < [replies, retweets] >
\item \emph{ @param } start_time character
\item \emph{ @param } end_time character
\item \emph{ @param } tweet_fields Enum < [attachments, author_id, context_annotations, conversation_id, created_at, entities, geo, id, in_reply_to_user_id, lang, non_public_metrics, organic_metrics, possibly_sensitive, promoted_metrics, public_metrics, referenced_tweets, reply_settings, source, text, withheld] >
\item \emph{ @param } expansions Enum < [attachments.media_keys, attachments.poll_ids, author_id, entities.mentions.username, geo.place_id, in_reply_to_user_id, referenced_tweets.id, referenced_tweets.id.author_id] >
\item \emph{ @param } media_fields Enum < [alt_text, duration_ms, height, media_key, non_public_metrics, organic_metrics, preview_image_url, promoted_metrics, public_metrics, type, url, variants, width] >
\item \emph{ @param } poll_fields Enum < [duration_minutes, end_datetime, id, options, voting_status] >
\item \emph{ @param } user_fields Enum < [created_at, description, entities, id, location, name, pinned_tweet_id, profile_image_url, protected, public_metrics, url, username, verified, withheld] >
\item \emph{ @param } place_fields Enum < [contained_within, country, country_code, full_name, geo, id, name, place_type] >
\item \emph{ @returnType } \link{Get2UsersIdTweetsResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : Get2UsersIdTweetsResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ users_id_unlike } \emph{ Causes the User (in the path) to unlike the specified Tweet }
Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } tweet_id character
\item \emph{ @returnType } \link{UsersLikesDeleteResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : UsersLikesDeleteResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

\strong{ users_id_unretweets } \emph{ Causes the User (in the path) to unretweet the specified Tweet }
Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request

\itemize{
\item \emph{ @param } id character
\item \emph{ @param } source_tweet_id character
\item \emph{ @returnType } \link{UsersRetweetsDeleteResponse} \cr

\item On encountering errors, an error of subclass ApiException will be thrown.

\item status code : 200 | The request has succeeded.

\item return type : UsersRetweetsDeleteResponse
\item response headers :

\tabular{ll}{
}
\item status code : 0 | The request has failed.

\item return type : Error
\item response headers :

\tabular{ll}{
}
}

}
}

\examples{
\dontrun{
####################  add_or_delete_rules  ####################

library(twitter)
var.add_or_delete_rules_request <- AddOrDeleteRulesRequest$new() # AddOrDeleteRulesRequest | 
var.dry_run <- "dry_run_example" # character | Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.

#Add/Delete rules
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

result <- tryCatch(
            api.instance$add_or_delete_rules(var.add_or_delete_rules_request, dry_run=var.dry_run),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  create_tweet  ####################

library(twitter)
var.tweet_create_request <- TweetCreateRequest$new() # TweetCreateRequest | 

#Creation of a Tweet
api.instance <- TweetsApi$new()

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$create_tweet(var.tweet_create_request),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  delete_tweet_by_id  ####################

library(twitter)
var.id <- "id_example" # character | The ID of the Tweet to be deleted.

#Tweet delete by Tweet ID
api.instance <- TweetsApi$new()

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$delete_tweet_by_id(var.id),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  find_tweet_by_id  ####################

library(twitter)
var.id <- "id_example" # character | A single Tweet ID.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#Tweet lookup by Tweet ID
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$find_tweet_by_id(var.id, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  find_tweets_by_id  ####################

library(twitter)
var.ids <- ["ids_example"] # array[character] | A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#Tweet lookup by Tweet IDs
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$find_tweets_by_id(var.ids, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  find_tweets_that_quote_a_tweet  ####################

library(twitter)
var.id <- "id_example" # character | A single Tweet ID.
var.max_results <- 10 # integer | The maximum number of results to be returned.
var.pagination_token <- "pagination_token_example" # character | This parameter is used to get a specified 'page' of results.
var.exclude <- ["[\"replies\",\"retweets\"]"] # set[character] | The set of entities to exclude (e.g. 'replies' or 'retweets').
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#Retrieve Tweets that quote a Tweet.
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$find_tweets_that_quote_a_tweet(var.id, max_results=var.max_results, pagination_token=var.pagination_token, exclude=var.exclude, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  get_rules  ####################

library(twitter)
var.ids <- ["ids_example"] # array[character] | A comma-separated list of Rule IDs.
var.max_results <- 1000 # integer | The maximum number of results.
var.pagination_token <- "pagination_token_example" # character | This value is populated by passing the 'next_token' returned in a request to paginate through results.

#Rules lookup
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

result <- tryCatch(
            api.instance$get_rules(ids=var.ids, max_results=var.max_results, pagination_token=var.pagination_token),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  get_tweets_firehose_stream  ####################

library(twitter)
var.partition <- 56 # integer | The partition number.
var.backfill_minutes <- 56 # integer | The number of minutes of backfill requested.
var.start_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
var.end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#Firehose stream
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

result <- tryCatch(
            api.instance$get_tweets_firehose_stream(var.partition, backfill_minutes=var.backfill_minutes, start_time=var.start_time, end_time=var.end_time, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  get_tweets_sample10_stream  ####################

library(twitter)
var.partition <- 56 # integer | The partition number.
var.backfill_minutes <- 56 # integer | The number of minutes of backfill requested.
var.start_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
var.end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#Sample 10\% stream
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

result <- tryCatch(
            api.instance$get_tweets_sample10_stream(var.partition, backfill_minutes=var.backfill_minutes, start_time=var.start_time, end_time=var.end_time, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  hide_reply_by_id  ####################

library(twitter)
var.tweet_id <- "tweet_id_example" # character | The ID of the reply that you want to hide or unhide.
var.tweet_hide_request <- TweetHideRequest$new() # TweetHideRequest | 

#Hide replies
api.instance <- TweetsApi$new()

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$hide_reply_by_id(var.tweet_id, tweet_hide_request=var.tweet_hide_request),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  lists_id_tweets  ####################

library(twitter)
var.id <- "id_example" # character | The ID of the List.
var.max_results <- 100 # integer | The maximum number of results.
var.pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#List Tweets timeline by List ID.
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$lists_id_tweets(var.id, max_results=var.max_results, pagination_token=var.pagination_token, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  sample_stream  ####################

library(twitter)
var.backfill_minutes <- 56 # integer | The number of minutes of backfill requested.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#Sample stream
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

result <- tryCatch(
            api.instance$sample_stream(backfill_minutes=var.backfill_minutes, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  search_stream  ####################

library(twitter)
var.backfill_minutes <- 56 # integer | The number of minutes of backfill requested.
var.start_time <- "2021-02-01T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
var.end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#Filtered stream
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

result <- tryCatch(
            api.instance$search_stream(backfill_minutes=var.backfill_minutes, start_time=var.start_time, end_time=var.end_time, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  space_buyers  ####################

library(twitter)
var.id <- "1YqKDqWqdPLsV" # character | The ID of the Space to be retrieved.
var.pagination_token <- "pagination_token_example" # character | This parameter is used to get a specified 'page' of results.
var.max_results <- 100 # integer | The maximum number of results.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.expansions <- ["[\"pinned_tweet_id\"]"] # set[character] | A comma separated list of fields to expand.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.

#Retrieve the list of Users who purchased a ticket to the given space
api.instance <- TweetsApi$new()

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';

result <- tryCatch(
            api.instance$space_buyers(var.id, pagination_token=var.pagination_token, max_results=var.max_results, user_fields=var.user_fields, expansions=var.expansions, tweet_fields=var.tweet_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  space_tweets  ####################

library(twitter)
var.id <- "1YqKDqWqdPLsV" # character | The ID of the Space to be retrieved.
var.max_results <- 100 # integer | The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#Retrieve Tweets from a Space.
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';

result <- tryCatch(
            api.instance$space_tweets(var.id, max_results=var.max_results, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  tweet_counts_full_archive_search  ####################

library(twitter)
var.query <- "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet" # character | One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
var.start_time <- "start_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
var.end_time <- "end_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
var.since_id <- "since_id_example" # character | Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
var.until_id <- "until_id_example" # character | Returns results with a Tweet ID less than (that is, older than) the specified ID.
var.next_token <- "next_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
var.pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
var.granularity <- "hour" # character | The granularity for the search counts results.
var.search_count_fields <- ["[\"end\",\"start\",\"tweet_count\"]"] # set[character] | A comma separated list of SearchCount fields to display.

#Full archive search counts
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

result <- tryCatch(
            api.instance$tweet_counts_full_archive_search(var.query, start_time=var.start_time, end_time=var.end_time, since_id=var.since_id, until_id=var.until_id, next_token=var.next_token, pagination_token=var.pagination_token, granularity=var.granularity, search_count_fields=var.search_count_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  tweet_counts_recent_search  ####################

library(twitter)
var.query <- "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet" # character | One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
var.start_time <- "start_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
var.end_time <- "end_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
var.since_id <- "since_id_example" # character | Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
var.until_id <- "until_id_example" # character | Returns results with a Tweet ID less than (that is, older than) the specified ID.
var.next_token <- "next_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
var.pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
var.granularity <- "hour" # character | The granularity for the search counts results.
var.search_count_fields <- ["[\"end\",\"start\",\"tweet_count\"]"] # set[character] | A comma separated list of SearchCount fields to display.

#Recent search counts
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

result <- tryCatch(
            api.instance$tweet_counts_recent_search(var.query, start_time=var.start_time, end_time=var.end_time, since_id=var.since_id, until_id=var.until_id, next_token=var.next_token, pagination_token=var.pagination_token, granularity=var.granularity, search_count_fields=var.search_count_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  tweets_fullarchive_search  ####################

library(twitter)
var.query <- "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet" # character | One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
var.start_time <- "start_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
var.end_time <- "end_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
var.since_id <- "since_id_example" # character | Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
var.until_id <- "until_id_example" # character | Returns results with a Tweet ID less than (that is, older than) the specified ID.
var.max_results <- 10 # integer | The maximum number of search results to be returned by a request.
var.next_token <- "next_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
var.pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
var.sort_order <- "sort_order_example" # character | This order in which to return results.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#Full-archive search
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

result <- tryCatch(
            api.instance$tweets_fullarchive_search(var.query, start_time=var.start_time, end_time=var.end_time, since_id=var.since_id, until_id=var.until_id, max_results=var.max_results, next_token=var.next_token, pagination_token=var.pagination_token, sort_order=var.sort_order, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  tweets_recent_search  ####################

library(twitter)
var.query <- "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet" # character | One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
var.start_time <- "start_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
var.end_time <- "end_time_example" # character | YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
var.since_id <- "since_id_example" # character | Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
var.until_id <- "until_id_example" # character | Returns results with a Tweet ID less than (that is, older than) the specified ID.
var.max_results <- 10 # integer | The maximum number of search results to be returned by a request.
var.next_token <- "next_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
var.pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
var.sort_order <- "sort_order_example" # character | This order in which to return results.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#Recent search
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$tweets_recent_search(var.query, start_time=var.start_time, end_time=var.end_time, since_id=var.since_id, until_id=var.until_id, max_results=var.max_results, next_token=var.next_token, pagination_token=var.pagination_token, sort_order=var.sort_order, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  users_id_like  ####################

library(twitter)
var.id <- "id_example" # character | The ID of the authenticated source User that is requesting to like the Tweet.
var.users_likes_create_request <- UsersLikesCreateRequest$new() # UsersLikesCreateRequest | 

#Causes the User (in the path) to like the specified Tweet
api.instance <- TweetsApi$new()

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$users_id_like(var.id, users_likes_create_request=var.users_likes_create_request),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  users_id_liked_tweets  ####################

library(twitter)
var.id <- "2244994945" # character | The ID of the User to lookup.
var.max_results <- 56 # integer | The maximum number of results.
var.pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#Returns Tweet objects liked by the provided User ID
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$users_id_liked_tweets(var.id, max_results=var.max_results, pagination_token=var.pagination_token, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  users_id_mentions  ####################

library(twitter)
var.id <- "2244994945" # character | The ID of the User to lookup.
var.since_id <- "since_id_example" # character | The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
var.until_id <- "1346889436626259968" # character | The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
var.max_results <- 56 # integer | The maximum number of results.
var.pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
var.start_time <- "2021-02-01T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
var.end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#User mention timeline by User ID
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$users_id_mentions(var.id, since_id=var.since_id, until_id=var.until_id, max_results=var.max_results, pagination_token=var.pagination_token, start_time=var.start_time, end_time=var.end_time, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  users_id_retweets  ####################

library(twitter)
var.id <- "id_example" # character | The ID of the authenticated source User that is requesting to retweet the Tweet.
var.users_retweets_create_request <- UsersRetweetsCreateRequest$new() # UsersRetweetsCreateRequest | 

#Causes the User (in the path) to retweet the specified Tweet.
api.instance <- TweetsApi$new()

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$users_id_retweets(var.id, users_retweets_create_request=var.users_retweets_create_request),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  users_id_timeline  ####################

library(twitter)
var.id <- "id_example" # character | The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.
var.since_id <- "791775337160081409" # character | The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
var.until_id <- "1346889436626259968" # character | The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
var.max_results <- 56 # integer | The maximum number of results.
var.pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
var.exclude <- ["[\"replies\",\"retweets\"]"] # set[character] | The set of entities to exclude (e.g. 'replies' or 'retweets').
var.start_time <- "2021-02-01T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
var.end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#User home timeline by User ID
api.instance <- TweetsApi$new()

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$users_id_timeline(var.id, since_id=var.since_id, until_id=var.until_id, max_results=var.max_results, pagination_token=var.pagination_token, exclude=var.exclude, start_time=var.start_time, end_time=var.end_time, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  users_id_tweets  ####################

library(twitter)
var.id <- "2244994945" # character | The ID of the User to lookup.
var.since_id <- "791775337160081409" # character | The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
var.until_id <- "1346889436626259968" # character | The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
var.max_results <- 56 # integer | The maximum number of results.
var.pagination_token <- "pagination_token_example" # character | This parameter is used to get the next 'page' of results.
var.exclude <- ["[\"replies\",\"retweets\"]"] # set[character] | The set of entities to exclude (e.g. 'replies' or 'retweets').
var.start_time <- "2021-02-01T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
var.end_time <- "2021-02-14T18:40:40.000Z" # character | YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
var.tweet_fields <- ["[\"attachments\",\"author_id\",\"context_annotations\",\"conversation_id\",\"created_at\",\"entities\",\"geo\",\"id\",\"in_reply_to_user_id\",\"lang\",\"non_public_metrics\",\"organic_metrics\",\"possibly_sensitive\",\"promoted_metrics\",\"public_metrics\",\"referenced_tweets\",\"reply_settings\",\"source\",\"text\",\"withheld\"]"] # set[character] | A comma separated list of Tweet fields to display.
var.expansions <- ["[\"attachments.media_keys\",\"attachments.poll_ids\",\"author_id\",\"entities.mentions.username\",\"geo.place_id\",\"in_reply_to_user_id\",\"referenced_tweets.id\",\"referenced_tweets.id.author_id\"]"] # set[character] | A comma separated list of fields to expand.
var.media_fields <- ["[\"alt_text\",\"duration_ms\",\"height\",\"media_key\",\"non_public_metrics\",\"organic_metrics\",\"preview_image_url\",\"promoted_metrics\",\"public_metrics\",\"type\",\"url\",\"variants\",\"width\"]"] # set[character] | A comma separated list of Media fields to display.
var.poll_fields <- ["[\"duration_minutes\",\"end_datetime\",\"id\",\"options\",\"voting_status\"]"] # set[character] | A comma separated list of Poll fields to display.
var.user_fields <- ["[\"created_at\",\"description\",\"entities\",\"id\",\"location\",\"name\",\"pinned_tweet_id\",\"profile_image_url\",\"protected\",\"public_metrics\",\"url\",\"username\",\"verified\",\"withheld\"]"] # set[character] | A comma separated list of User fields to display.
var.place_fields <- ["[\"contained_within\",\"country\",\"country_code\",\"full_name\",\"geo\",\"id\",\"name\",\"place_type\"]"] # set[character] | A comma separated list of Place fields to display.

#User Tweets timeline by User ID
api.instance <- TweetsApi$new()

#Configure HTTP bearer authorization: BearerToken
api.instance$api_client$bearer_token <- 'TODO_YOUR_BEARER_TOKEN';

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$users_id_tweets(var.id, since_id=var.since_id, until_id=var.until_id, max_results=var.max_results, pagination_token=var.pagination_token, exclude=var.exclude, start_time=var.start_time, end_time=var.end_time, tweet_fields=var.tweet_fields, expansions=var.expansions, media_fields=var.media_fields, poll_fields=var.poll_fields, user_fields=var.user_fields, place_fields=var.place_fields),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  users_id_unlike  ####################

library(twitter)
var.id <- "id_example" # character | The ID of the authenticated source User that is requesting to unlike the Tweet.
var.tweet_id <- "tweet_id_example" # character | The ID of the Tweet that the User is requesting to unlike.

#Causes the User (in the path) to unlike the specified Tweet
api.instance <- TweetsApi$new()

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$users_id_unlike(var.id, var.tweet_id),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


####################  users_id_unretweets  ####################

library(twitter)
var.id <- "id_example" # character | The ID of the authenticated source User that is requesting to retweet the Tweet.
var.source_tweet_id <- "source_tweet_id_example" # character | The ID of the Tweet that the User is requesting to unretweet.

#Causes the User (in the path) to unretweet the specified Tweet
api.instance <- TweetsApi$new()

# Configure OAuth2 access token for authorization: OAuth2UserToken
api.instance$api_client$access_token <- 'TODO_YOUR_ACCESS_TOKEN';


result <- tryCatch(
            api.instance$users_id_unretweets(var.id, var.source_tweet_id),
            ApiException = function(ex) ex
         )
# In case of error, print the error object
if(!is.null(result$ApiException)) {
  cat(result$ApiException$toString())
} else {
# deserialized response object
response.object <- result$content
# response headers
response.headers <- result$response$headers
# response status code
response.status.code <- result$response$status_code
}


}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{api_client}}{Handles the client-server communication.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-TweetsApi-new}{\code{TweetsApi$new()}}
\item \href{#method-TweetsApi-add_or_delete_rules}{\code{TweetsApi$add_or_delete_rules()}}
\item \href{#method-TweetsApi-add_or_delete_rules_with_http_info}{\code{TweetsApi$add_or_delete_rules_with_http_info()}}
\item \href{#method-TweetsApi-create_tweet}{\code{TweetsApi$create_tweet()}}
\item \href{#method-TweetsApi-create_tweet_with_http_info}{\code{TweetsApi$create_tweet_with_http_info()}}
\item \href{#method-TweetsApi-delete_tweet_by_id}{\code{TweetsApi$delete_tweet_by_id()}}
\item \href{#method-TweetsApi-delete_tweet_by_id_with_http_info}{\code{TweetsApi$delete_tweet_by_id_with_http_info()}}
\item \href{#method-TweetsApi-find_tweet_by_id}{\code{TweetsApi$find_tweet_by_id()}}
\item \href{#method-TweetsApi-find_tweet_by_id_with_http_info}{\code{TweetsApi$find_tweet_by_id_with_http_info()}}
\item \href{#method-TweetsApi-find_tweets_by_id}{\code{TweetsApi$find_tweets_by_id()}}
\item \href{#method-TweetsApi-find_tweets_by_id_with_http_info}{\code{TweetsApi$find_tweets_by_id_with_http_info()}}
\item \href{#method-TweetsApi-find_tweets_that_quote_a_tweet}{\code{TweetsApi$find_tweets_that_quote_a_tweet()}}
\item \href{#method-TweetsApi-find_tweets_that_quote_a_tweet_with_http_info}{\code{TweetsApi$find_tweets_that_quote_a_tweet_with_http_info()}}
\item \href{#method-TweetsApi-get_rules}{\code{TweetsApi$get_rules()}}
\item \href{#method-TweetsApi-get_rules_with_http_info}{\code{TweetsApi$get_rules_with_http_info()}}
\item \href{#method-TweetsApi-get_tweets_firehose_stream}{\code{TweetsApi$get_tweets_firehose_stream()}}
\item \href{#method-TweetsApi-get_tweets_firehose_stream_with_http_info}{\code{TweetsApi$get_tweets_firehose_stream_with_http_info()}}
\item \href{#method-TweetsApi-get_tweets_sample10_stream}{\code{TweetsApi$get_tweets_sample10_stream()}}
\item \href{#method-TweetsApi-get_tweets_sample10_stream_with_http_info}{\code{TweetsApi$get_tweets_sample10_stream_with_http_info()}}
\item \href{#method-TweetsApi-hide_reply_by_id}{\code{TweetsApi$hide_reply_by_id()}}
\item \href{#method-TweetsApi-hide_reply_by_id_with_http_info}{\code{TweetsApi$hide_reply_by_id_with_http_info()}}
\item \href{#method-TweetsApi-lists_id_tweets}{\code{TweetsApi$lists_id_tweets()}}
\item \href{#method-TweetsApi-lists_id_tweets_with_http_info}{\code{TweetsApi$lists_id_tweets_with_http_info()}}
\item \href{#method-TweetsApi-sample_stream}{\code{TweetsApi$sample_stream()}}
\item \href{#method-TweetsApi-sample_stream_with_http_info}{\code{TweetsApi$sample_stream_with_http_info()}}
\item \href{#method-TweetsApi-search_stream}{\code{TweetsApi$search_stream()}}
\item \href{#method-TweetsApi-search_stream_with_http_info}{\code{TweetsApi$search_stream_with_http_info()}}
\item \href{#method-TweetsApi-space_buyers}{\code{TweetsApi$space_buyers()}}
\item \href{#method-TweetsApi-space_buyers_with_http_info}{\code{TweetsApi$space_buyers_with_http_info()}}
\item \href{#method-TweetsApi-space_tweets}{\code{TweetsApi$space_tweets()}}
\item \href{#method-TweetsApi-space_tweets_with_http_info}{\code{TweetsApi$space_tweets_with_http_info()}}
\item \href{#method-TweetsApi-tweet_counts_full_archive_search}{\code{TweetsApi$tweet_counts_full_archive_search()}}
\item \href{#method-TweetsApi-tweet_counts_full_archive_search_with_http_info}{\code{TweetsApi$tweet_counts_full_archive_search_with_http_info()}}
\item \href{#method-TweetsApi-tweet_counts_recent_search}{\code{TweetsApi$tweet_counts_recent_search()}}
\item \href{#method-TweetsApi-tweet_counts_recent_search_with_http_info}{\code{TweetsApi$tweet_counts_recent_search_with_http_info()}}
\item \href{#method-TweetsApi-tweets_fullarchive_search}{\code{TweetsApi$tweets_fullarchive_search()}}
\item \href{#method-TweetsApi-tweets_fullarchive_search_with_http_info}{\code{TweetsApi$tweets_fullarchive_search_with_http_info()}}
\item \href{#method-TweetsApi-tweets_recent_search}{\code{TweetsApi$tweets_recent_search()}}
\item \href{#method-TweetsApi-tweets_recent_search_with_http_info}{\code{TweetsApi$tweets_recent_search_with_http_info()}}
\item \href{#method-TweetsApi-users_id_like}{\code{TweetsApi$users_id_like()}}
\item \href{#method-TweetsApi-users_id_like_with_http_info}{\code{TweetsApi$users_id_like_with_http_info()}}
\item \href{#method-TweetsApi-users_id_liked_tweets}{\code{TweetsApi$users_id_liked_tweets()}}
\item \href{#method-TweetsApi-users_id_liked_tweets_with_http_info}{\code{TweetsApi$users_id_liked_tweets_with_http_info()}}
\item \href{#method-TweetsApi-users_id_mentions}{\code{TweetsApi$users_id_mentions()}}
\item \href{#method-TweetsApi-users_id_mentions_with_http_info}{\code{TweetsApi$users_id_mentions_with_http_info()}}
\item \href{#method-TweetsApi-users_id_retweets}{\code{TweetsApi$users_id_retweets()}}
\item \href{#method-TweetsApi-users_id_retweets_with_http_info}{\code{TweetsApi$users_id_retweets_with_http_info()}}
\item \href{#method-TweetsApi-users_id_timeline}{\code{TweetsApi$users_id_timeline()}}
\item \href{#method-TweetsApi-users_id_timeline_with_http_info}{\code{TweetsApi$users_id_timeline_with_http_info()}}
\item \href{#method-TweetsApi-users_id_tweets}{\code{TweetsApi$users_id_tweets()}}
\item \href{#method-TweetsApi-users_id_tweets_with_http_info}{\code{TweetsApi$users_id_tweets_with_http_info()}}
\item \href{#method-TweetsApi-users_id_unlike}{\code{TweetsApi$users_id_unlike()}}
\item \href{#method-TweetsApi-users_id_unlike_with_http_info}{\code{TweetsApi$users_id_unlike_with_http_info()}}
\item \href{#method-TweetsApi-users_id_unretweets}{\code{TweetsApi$users_id_unretweets()}}
\item \href{#method-TweetsApi-users_id_unretweets_with_http_info}{\code{TweetsApi$users_id_unretweets_with_http_info()}}
\item \href{#method-TweetsApi-clone}{\code{TweetsApi$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-new"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-new}{}}}
\subsection{Method \code{new()}}{
Initialize a new TweetsApi.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$new(api_client)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{api_client}}{An instance of API client.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-add_or_delete_rules"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-add_or_delete_rules}{}}}
\subsection{Method \code{add_or_delete_rules()}}{
Add/Delete rules
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$add_or_delete_rules(
  add_or_delete_rules_request,
  dry_run = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{add_or_delete_rules_request}}{}

\item{\code{dry_run}}{(optional) Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
AddOrDeleteRulesResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-add_or_delete_rules_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-add_or_delete_rules_with_http_info}{}}}
\subsection{Method \code{add_or_delete_rules_with_http_info()}}{
Add/Delete rules
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$add_or_delete_rules_with_http_info(
  add_or_delete_rules_request,
  dry_run = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{add_or_delete_rules_request}}{}

\item{\code{dry_run}}{(optional) Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (AddOrDeleteRulesResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-create_tweet"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-create_tweet}{}}}
\subsection{Method \code{create_tweet()}}{
Creation of a Tweet
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$create_tweet(tweet_create_request, data_file = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tweet_create_request}}{}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
TweetCreateResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-create_tweet_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-create_tweet_with_http_info}{}}}
\subsection{Method \code{create_tweet_with_http_info()}}{
Creation of a Tweet
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$create_tweet_with_http_info(
  tweet_create_request,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tweet_create_request}}{}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (TweetCreateResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-delete_tweet_by_id"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-delete_tweet_by_id}{}}}
\subsection{Method \code{delete_tweet_by_id()}}{
Tweet delete by Tweet ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$delete_tweet_by_id(id, data_file = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the Tweet to be deleted.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
TweetDeleteResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-delete_tweet_by_id_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-delete_tweet_by_id_with_http_info}{}}}
\subsection{Method \code{delete_tweet_by_id_with_http_info()}}{
Tweet delete by Tweet ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$delete_tweet_by_id_with_http_info(id, data_file = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the Tweet to be deleted.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (TweetDeleteResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-find_tweet_by_id"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-find_tweet_by_id}{}}}
\subsection{Method \code{find_tweet_by_id()}}{
Tweet lookup by Tweet ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$find_tweet_by_id(
  id,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{A single Tweet ID.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2TweetsIdResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-find_tweet_by_id_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-find_tweet_by_id_with_http_info}{}}}
\subsection{Method \code{find_tweet_by_id_with_http_info()}}{
Tweet lookup by Tweet ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$find_tweet_by_id_with_http_info(
  id,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{A single Tweet ID.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2TweetsIdResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-find_tweets_by_id"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-find_tweets_by_id}{}}}
\subsection{Method \code{find_tweets_by_id()}}{
Tweet lookup by Tweet IDs
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$find_tweets_by_id(
  ids,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ids}}{A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2TweetsResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-find_tweets_by_id_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-find_tweets_by_id_with_http_info}{}}}
\subsection{Method \code{find_tweets_by_id_with_http_info()}}{
Tweet lookup by Tweet IDs
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$find_tweets_by_id_with_http_info(
  ids,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ids}}{A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2TweetsResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-find_tweets_that_quote_a_tweet"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-find_tweets_that_quote_a_tweet}{}}}
\subsection{Method \code{find_tweets_that_quote_a_tweet()}}{
Retrieve Tweets that quote a Tweet.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$find_tweets_that_quote_a_tweet(
  id,
  max_results = 10,
  pagination_token = NULL,
  exclude = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{A single Tweet ID.}

\item{\code{max_results}}{(optional) The maximum number of results to be returned. (default value: 10)}

\item{\code{pagination_token}}{(optional) This parameter is used to get a specified 'page' of results.}

\item{\code{exclude}}{(optional) The set of entities to exclude (e.g. 'replies' or 'retweets').}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2TweetsIdQuoteTweetsResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-find_tweets_that_quote_a_tweet_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-find_tweets_that_quote_a_tweet_with_http_info}{}}}
\subsection{Method \code{find_tweets_that_quote_a_tweet_with_http_info()}}{
Retrieve Tweets that quote a Tweet.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$find_tweets_that_quote_a_tweet_with_http_info(
  id,
  max_results = 10,
  pagination_token = NULL,
  exclude = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{A single Tweet ID.}

\item{\code{max_results}}{(optional) The maximum number of results to be returned. (default value: 10)}

\item{\code{pagination_token}}{(optional) This parameter is used to get a specified 'page' of results.}

\item{\code{exclude}}{(optional) The set of entities to exclude (e.g. 'replies' or 'retweets').}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2TweetsIdQuoteTweetsResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-get_rules"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-get_rules}{}}}
\subsection{Method \code{get_rules()}}{
Rules lookup
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$get_rules(
  ids = NULL,
  max_results = 1000,
  pagination_token = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ids}}{(optional) A comma-separated list of Rule IDs.}

\item{\code{max_results}}{(optional) The maximum number of results. (default value: 1000)}

\item{\code{pagination_token}}{(optional) This value is populated by passing the 'next_token' returned in a request to paginate through results.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
RulesLookupResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-get_rules_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-get_rules_with_http_info}{}}}
\subsection{Method \code{get_rules_with_http_info()}}{
Rules lookup
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$get_rules_with_http_info(
  ids = NULL,
  max_results = 1000,
  pagination_token = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ids}}{(optional) A comma-separated list of Rule IDs.}

\item{\code{max_results}}{(optional) The maximum number of results. (default value: 1000)}

\item{\code{pagination_token}}{(optional) This value is populated by passing the 'next_token' returned in a request to paginate through results.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (RulesLookupResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-get_tweets_firehose_stream"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-get_tweets_firehose_stream}{}}}
\subsection{Method \code{get_tweets_firehose_stream()}}{
Firehose stream
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$get_tweets_firehose_stream(
  partition,
  backfill_minutes = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{partition}}{The partition number.}

\item{\code{backfill_minutes}}{(optional) The number of minutes of backfill requested.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
StreamingTweetResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-get_tweets_firehose_stream_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-get_tweets_firehose_stream_with_http_info}{}}}
\subsection{Method \code{get_tweets_firehose_stream_with_http_info()}}{
Firehose stream
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$get_tweets_firehose_stream_with_http_info(
  partition,
  backfill_minutes = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{partition}}{The partition number.}

\item{\code{backfill_minutes}}{(optional) The number of minutes of backfill requested.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (StreamingTweetResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-get_tweets_sample10_stream"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-get_tweets_sample10_stream}{}}}
\subsection{Method \code{get_tweets_sample10_stream()}}{
Sample 10% stream
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$get_tweets_sample10_stream(
  partition,
  backfill_minutes = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{partition}}{The partition number.}

\item{\code{backfill_minutes}}{(optional) The number of minutes of backfill requested.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2TweetsSample10StreamResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-get_tweets_sample10_stream_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-get_tweets_sample10_stream_with_http_info}{}}}
\subsection{Method \code{get_tweets_sample10_stream_with_http_info()}}{
Sample 10% stream
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$get_tweets_sample10_stream_with_http_info(
  partition,
  backfill_minutes = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{partition}}{The partition number.}

\item{\code{backfill_minutes}}{(optional) The number of minutes of backfill requested.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2TweetsSample10StreamResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-hide_reply_by_id"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-hide_reply_by_id}{}}}
\subsection{Method \code{hide_reply_by_id()}}{
Hide replies
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$hide_reply_by_id(
  tweet_id,
  tweet_hide_request = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tweet_id}}{The ID of the reply that you want to hide or unhide.}

\item{\code{tweet_hide_request}}{(optional) No description}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
TweetHideResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-hide_reply_by_id_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-hide_reply_by_id_with_http_info}{}}}
\subsection{Method \code{hide_reply_by_id_with_http_info()}}{
Hide replies
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$hide_reply_by_id_with_http_info(
  tweet_id,
  tweet_hide_request = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tweet_id}}{The ID of the reply that you want to hide or unhide.}

\item{\code{tweet_hide_request}}{(optional) No description}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (TweetHideResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-lists_id_tweets"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-lists_id_tweets}{}}}
\subsection{Method \code{lists_id_tweets()}}{
List Tweets timeline by List ID.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$lists_id_tweets(
  id,
  max_results = 100,
  pagination_token = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the List.}

\item{\code{max_results}}{(optional) The maximum number of results. (default value: 100)}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2ListsIdTweetsResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-lists_id_tweets_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-lists_id_tweets_with_http_info}{}}}
\subsection{Method \code{lists_id_tweets_with_http_info()}}{
List Tweets timeline by List ID.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$lists_id_tweets_with_http_info(
  id,
  max_results = 100,
  pagination_token = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the List.}

\item{\code{max_results}}{(optional) The maximum number of results. (default value: 100)}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2ListsIdTweetsResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-sample_stream"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-sample_stream}{}}}
\subsection{Method \code{sample_stream()}}{
Sample stream
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$sample_stream(
  backfill_minutes = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{backfill_minutes}}{(optional) The number of minutes of backfill requested.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
StreamingTweetResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-sample_stream_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-sample_stream_with_http_info}{}}}
\subsection{Method \code{sample_stream_with_http_info()}}{
Sample stream
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$sample_stream_with_http_info(
  backfill_minutes = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{backfill_minutes}}{(optional) The number of minutes of backfill requested.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (StreamingTweetResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-search_stream"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-search_stream}{}}}
\subsection{Method \code{search_stream()}}{
Filtered stream
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$search_stream(
  backfill_minutes = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{backfill_minutes}}{(optional) The number of minutes of backfill requested.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
FilteredStreamingTweetResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-search_stream_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-search_stream_with_http_info}{}}}
\subsection{Method \code{search_stream_with_http_info()}}{
Filtered stream
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$search_stream_with_http_info(
  backfill_minutes = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{backfill_minutes}}{(optional) The number of minutes of backfill requested.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (FilteredStreamingTweetResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-space_buyers"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-space_buyers}{}}}
\subsection{Method \code{space_buyers()}}{
Retrieve the list of Users who purchased a ticket to the given space
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$space_buyers(
  id,
  pagination_token = NULL,
  max_results = 100,
  user_fields = NULL,
  expansions = NULL,
  tweet_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the Space to be retrieved.}

\item{\code{pagination_token}}{(optional) This parameter is used to get a specified 'page' of results.}

\item{\code{max_results}}{(optional) The maximum number of results. (default value: 100)}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2SpacesIdBuyersResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-space_buyers_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-space_buyers_with_http_info}{}}}
\subsection{Method \code{space_buyers_with_http_info()}}{
Retrieve the list of Users who purchased a ticket to the given space
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$space_buyers_with_http_info(
  id,
  pagination_token = NULL,
  max_results = 100,
  user_fields = NULL,
  expansions = NULL,
  tweet_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the Space to be retrieved.}

\item{\code{pagination_token}}{(optional) This parameter is used to get a specified 'page' of results.}

\item{\code{max_results}}{(optional) The maximum number of results. (default value: 100)}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2SpacesIdBuyersResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-space_tweets"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-space_tweets}{}}}
\subsection{Method \code{space_tweets()}}{
Retrieve Tweets from a Space.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$space_tweets(
  id,
  max_results = 100,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the Space to be retrieved.}

\item{\code{max_results}}{(optional) The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (default value: 100)}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2SpacesIdTweetsResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-space_tweets_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-space_tweets_with_http_info}{}}}
\subsection{Method \code{space_tweets_with_http_info()}}{
Retrieve Tweets from a Space.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$space_tweets_with_http_info(
  id,
  max_results = 100,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the Space to be retrieved.}

\item{\code{max_results}}{(optional) The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (default value: 100)}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2SpacesIdTweetsResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-tweet_counts_full_archive_search"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-tweet_counts_full_archive_search}{}}}
\subsection{Method \code{tweet_counts_full_archive_search()}}{
Full archive search counts
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$tweet_counts_full_archive_search(
  query,
  start_time = NULL,
  end_time = NULL,
  since_id = NULL,
  until_id = NULL,
  next_token = NULL,
  pagination_token = NULL,
  granularity = "hour",
  search_count_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).}

\item{\code{since_id}}{(optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.}

\item{\code{until_id}}{(optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.}

\item{\code{next_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{granularity}}{(optional) The granularity for the search counts results. (default value: "hour")}

\item{\code{search_count_fields}}{(optional) A comma separated list of SearchCount fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2TweetsCountsAllResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-tweet_counts_full_archive_search_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-tweet_counts_full_archive_search_with_http_info}{}}}
\subsection{Method \code{tweet_counts_full_archive_search_with_http_info()}}{
Full archive search counts
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$tweet_counts_full_archive_search_with_http_info(
  query,
  start_time = NULL,
  end_time = NULL,
  since_id = NULL,
  until_id = NULL,
  next_token = NULL,
  pagination_token = NULL,
  granularity = "hour",
  search_count_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).}

\item{\code{since_id}}{(optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.}

\item{\code{until_id}}{(optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.}

\item{\code{next_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{granularity}}{(optional) The granularity for the search counts results. (default value: "hour")}

\item{\code{search_count_fields}}{(optional) A comma separated list of SearchCount fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2TweetsCountsAllResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-tweet_counts_recent_search"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-tweet_counts_recent_search}{}}}
\subsection{Method \code{tweet_counts_recent_search()}}{
Recent search counts
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$tweet_counts_recent_search(
  query,
  start_time = NULL,
  end_time = NULL,
  since_id = NULL,
  until_id = NULL,
  next_token = NULL,
  pagination_token = NULL,
  granularity = "hour",
  search_count_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).}

\item{\code{since_id}}{(optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.}

\item{\code{until_id}}{(optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.}

\item{\code{next_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{granularity}}{(optional) The granularity for the search counts results. (default value: "hour")}

\item{\code{search_count_fields}}{(optional) A comma separated list of SearchCount fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2TweetsCountsRecentResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-tweet_counts_recent_search_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-tweet_counts_recent_search_with_http_info}{}}}
\subsection{Method \code{tweet_counts_recent_search_with_http_info()}}{
Recent search counts
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$tweet_counts_recent_search_with_http_info(
  query,
  start_time = NULL,
  end_time = NULL,
  since_id = NULL,
  until_id = NULL,
  next_token = NULL,
  pagination_token = NULL,
  granularity = "hour",
  search_count_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).}

\item{\code{since_id}}{(optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.}

\item{\code{until_id}}{(optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.}

\item{\code{next_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{granularity}}{(optional) The granularity for the search counts results. (default value: "hour")}

\item{\code{search_count_fields}}{(optional) A comma separated list of SearchCount fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2TweetsCountsRecentResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-tweets_fullarchive_search"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-tweets_fullarchive_search}{}}}
\subsection{Method \code{tweets_fullarchive_search()}}{
Full-archive search
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$tweets_fullarchive_search(
  query,
  start_time = NULL,
  end_time = NULL,
  since_id = NULL,
  until_id = NULL,
  max_results = 10,
  next_token = NULL,
  pagination_token = NULL,
  sort_order = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).}

\item{\code{since_id}}{(optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.}

\item{\code{until_id}}{(optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.}

\item{\code{max_results}}{(optional) The maximum number of search results to be returned by a request. (default value: 10)}

\item{\code{next_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{sort_order}}{(optional) This order in which to return results.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2TweetsSearchAllResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-tweets_fullarchive_search_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-tweets_fullarchive_search_with_http_info}{}}}
\subsection{Method \code{tweets_fullarchive_search_with_http_info()}}{
Full-archive search
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$tweets_fullarchive_search_with_http_info(
  query,
  start_time = NULL,
  end_time = NULL,
  since_id = NULL,
  until_id = NULL,
  max_results = 10,
  next_token = NULL,
  pagination_token = NULL,
  sort_order = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).}

\item{\code{since_id}}{(optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.}

\item{\code{until_id}}{(optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.}

\item{\code{max_results}}{(optional) The maximum number of search results to be returned by a request. (default value: 10)}

\item{\code{next_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{sort_order}}{(optional) This order in which to return results.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2TweetsSearchAllResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-tweets_recent_search"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-tweets_recent_search}{}}}
\subsection{Method \code{tweets_recent_search()}}{
Recent search
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$tweets_recent_search(
  query,
  start_time = NULL,
  end_time = NULL,
  since_id = NULL,
  until_id = NULL,
  max_results = 10,
  next_token = NULL,
  pagination_token = NULL,
  sort_order = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).}

\item{\code{since_id}}{(optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.}

\item{\code{until_id}}{(optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.}

\item{\code{max_results}}{(optional) The maximum number of search results to be returned by a request. (default value: 10)}

\item{\code{next_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{sort_order}}{(optional) This order in which to return results.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2TweetsSearchRecentResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-tweets_recent_search_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-tweets_recent_search_with_http_info}{}}}
\subsection{Method \code{tweets_recent_search_with_http_info()}}{
Recent search
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$tweets_recent_search_with_http_info(
  query,
  start_time = NULL,
  end_time = NULL,
  since_id = NULL,
  until_id = NULL,
  max_results = 10,
  next_token = NULL,
  pagination_token = NULL,
  sort_order = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).}

\item{\code{since_id}}{(optional) Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.}

\item{\code{until_id}}{(optional) Returns results with a Tweet ID less than (that is, older than) the specified ID.}

\item{\code{max_results}}{(optional) The maximum number of search results to be returned by a request. (default value: 10)}

\item{\code{next_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.}

\item{\code{sort_order}}{(optional) This order in which to return results.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2TweetsSearchRecentResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_like"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_like}{}}}
\subsection{Method \code{users_id_like()}}{
Causes the User (in the path) to like the specified Tweet
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_like(
  id,
  users_likes_create_request = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the authenticated source User that is requesting to like the Tweet.}

\item{\code{users_likes_create_request}}{(optional) No description}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
UsersLikesCreateResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_like_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_like_with_http_info}{}}}
\subsection{Method \code{users_id_like_with_http_info()}}{
Causes the User (in the path) to like the specified Tweet
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_like_with_http_info(
  id,
  users_likes_create_request = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the authenticated source User that is requesting to like the Tweet.}

\item{\code{users_likes_create_request}}{(optional) No description}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (UsersLikesCreateResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_liked_tweets"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_liked_tweets}{}}}
\subsection{Method \code{users_id_liked_tweets()}}{
Returns Tweet objects liked by the provided User ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_liked_tweets(
  id,
  max_results = NULL,
  pagination_token = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the User to lookup.}

\item{\code{max_results}}{(optional) The maximum number of results.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2UsersIdLikedTweetsResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_liked_tweets_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_liked_tweets_with_http_info}{}}}
\subsection{Method \code{users_id_liked_tweets_with_http_info()}}{
Returns Tweet objects liked by the provided User ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_liked_tweets_with_http_info(
  id,
  max_results = NULL,
  pagination_token = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the User to lookup.}

\item{\code{max_results}}{(optional) The maximum number of results.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2UsersIdLikedTweetsResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_mentions"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_mentions}{}}}
\subsection{Method \code{users_id_mentions()}}{
User mention timeline by User ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_mentions(
  id,
  since_id = NULL,
  until_id = NULL,
  max_results = NULL,
  pagination_token = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the User to lookup.}

\item{\code{since_id}}{(optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.}

\item{\code{until_id}}{(optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.}

\item{\code{max_results}}{(optional) The maximum number of results.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2UsersIdMentionsResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_mentions_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_mentions_with_http_info}{}}}
\subsection{Method \code{users_id_mentions_with_http_info()}}{
User mention timeline by User ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_mentions_with_http_info(
  id,
  since_id = NULL,
  until_id = NULL,
  max_results = NULL,
  pagination_token = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the User to lookup.}

\item{\code{since_id}}{(optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.}

\item{\code{until_id}}{(optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.}

\item{\code{max_results}}{(optional) The maximum number of results.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results.}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2UsersIdMentionsResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_retweets"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_retweets}{}}}
\subsection{Method \code{users_id_retweets()}}{
Causes the User (in the path) to retweet the specified Tweet.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_retweets(
  id,
  users_retweets_create_request = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the authenticated source User that is requesting to retweet the Tweet.}

\item{\code{users_retweets_create_request}}{(optional) No description}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
UsersRetweetsCreateResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_retweets_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_retweets_with_http_info}{}}}
\subsection{Method \code{users_id_retweets_with_http_info()}}{
Causes the User (in the path) to retweet the specified Tweet.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_retweets_with_http_info(
  id,
  users_retweets_create_request = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the authenticated source User that is requesting to retweet the Tweet.}

\item{\code{users_retweets_create_request}}{(optional) No description}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (UsersRetweetsCreateResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_timeline"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_timeline}{}}}
\subsection{Method \code{users_id_timeline()}}{
User home timeline by User ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_timeline(
  id,
  since_id = NULL,
  until_id = NULL,
  max_results = NULL,
  pagination_token = NULL,
  exclude = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.}

\item{\code{since_id}}{(optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.}

\item{\code{until_id}}{(optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.}

\item{\code{max_results}}{(optional) The maximum number of results.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results.}

\item{\code{exclude}}{(optional) The set of entities to exclude (e.g. 'replies' or 'retweets').}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2UsersIdTimelinesReverseChronologicalResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_timeline_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_timeline_with_http_info}{}}}
\subsection{Method \code{users_id_timeline_with_http_info()}}{
User home timeline by User ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_timeline_with_http_info(
  id,
  since_id = NULL,
  until_id = NULL,
  max_results = NULL,
  pagination_token = NULL,
  exclude = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.}

\item{\code{since_id}}{(optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.}

\item{\code{until_id}}{(optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.}

\item{\code{max_results}}{(optional) The maximum number of results.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results.}

\item{\code{exclude}}{(optional) The set of entities to exclude (e.g. 'replies' or 'retweets').}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2UsersIdTimelinesReverseChronologicalResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_tweets"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_tweets}{}}}
\subsection{Method \code{users_id_tweets()}}{
User Tweets timeline by User ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_tweets(
  id,
  since_id = NULL,
  until_id = NULL,
  max_results = NULL,
  pagination_token = NULL,
  exclude = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the User to lookup.}

\item{\code{since_id}}{(optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.}

\item{\code{until_id}}{(optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.}

\item{\code{max_results}}{(optional) The maximum number of results.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results.}

\item{\code{exclude}}{(optional) The set of entities to exclude (e.g. 'replies' or 'retweets').}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Get2UsersIdTweetsResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_tweets_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_tweets_with_http_info}{}}}
\subsection{Method \code{users_id_tweets_with_http_info()}}{
User Tweets timeline by User ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_tweets_with_http_info(
  id,
  since_id = NULL,
  until_id = NULL,
  max_results = NULL,
  pagination_token = NULL,
  exclude = NULL,
  start_time = NULL,
  end_time = NULL,
  tweet_fields = NULL,
  expansions = NULL,
  media_fields = NULL,
  poll_fields = NULL,
  user_fields = NULL,
  place_fields = NULL,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the User to lookup.}

\item{\code{since_id}}{(optional) The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.}

\item{\code{until_id}}{(optional) The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.}

\item{\code{max_results}}{(optional) The maximum number of results.}

\item{\code{pagination_token}}{(optional) This parameter is used to get the next 'page' of results.}

\item{\code{exclude}}{(optional) The set of entities to exclude (e.g. 'replies' or 'retweets').}

\item{\code{start_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.}

\item{\code{end_time}}{(optional) YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.}

\item{\code{tweet_fields}}{(optional) A comma separated list of Tweet fields to display.}

\item{\code{expansions}}{(optional) A comma separated list of fields to expand.}

\item{\code{media_fields}}{(optional) A comma separated list of Media fields to display.}

\item{\code{poll_fields}}{(optional) A comma separated list of Poll fields to display.}

\item{\code{user_fields}}{(optional) A comma separated list of User fields to display.}

\item{\code{place_fields}}{(optional) A comma separated list of Place fields to display.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (Get2UsersIdTweetsResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_unlike"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_unlike}{}}}
\subsection{Method \code{users_id_unlike()}}{
Causes the User (in the path) to unlike the specified Tweet
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_unlike(id, tweet_id, data_file = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the authenticated source User that is requesting to unlike the Tweet.}

\item{\code{tweet_id}}{The ID of the Tweet that the User is requesting to unlike.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
UsersLikesDeleteResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_unlike_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_unlike_with_http_info}{}}}
\subsection{Method \code{users_id_unlike_with_http_info()}}{
Causes the User (in the path) to unlike the specified Tweet
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_unlike_with_http_info(id, tweet_id, data_file = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the authenticated source User that is requesting to unlike the Tweet.}

\item{\code{tweet_id}}{The ID of the Tweet that the User is requesting to unlike.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (UsersLikesDeleteResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_unretweets"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_unretweets}{}}}
\subsection{Method \code{users_id_unretweets()}}{
Causes the User (in the path) to unretweet the specified Tweet
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_unretweets(id, source_tweet_id, data_file = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the authenticated source User that is requesting to retweet the Tweet.}

\item{\code{source_tweet_id}}{The ID of the Tweet that the User is requesting to unretweet.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
UsersRetweetsDeleteResponse
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-users_id_unretweets_with_http_info"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-users_id_unretweets_with_http_info}{}}}
\subsection{Method \code{users_id_unretweets_with_http_info()}}{
Causes the User (in the path) to unretweet the specified Tweet
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$users_id_unretweets_with_http_info(
  id,
  source_tweet_id,
  data_file = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{The ID of the authenticated source User that is requesting to retweet the Tweet.}

\item{\code{source_tweet_id}}{The ID of the Tweet that the User is requesting to unretweet.}

\item{\code{data_file}}{(optional) name of the data file to save the result}

\item{\code{...}}{Other optional arguments}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
API response (UsersRetweetsDeleteResponse) with additional information such as HTTP status code, headers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TweetsApi-clone"></a>}}
\if{latex}{\out{\hypertarget{method-TweetsApi-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TweetsApi$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
